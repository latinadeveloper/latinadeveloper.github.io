<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interfaz de Consulta de Active Record — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/default.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/rails-guides.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/prism.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/responsive-tables.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="Interfaz de Consulta de Active Record — Ruby on Rails Guides" />
  <meta name="description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Interfaz de Consulta de Active RecordEste guía cubre diferentes formas de recuperar datos de la base de datos utilizando Active Record.Después de leer esta guía, sabrás: Cómo encontrar registros utilizando una variedad de métodos y condiciones. Cómo especificar el orden, los atributos recuperados, la agrupación y otras propiedades de los registros encontrados. Cómo utilizar la carga ansiosa (eager loading) para reducir la cantidad de consultas a la base de datos necesarias para la recuperación de datos. Cómo usar los métodos de buscador dinámico. Cómo usar el método de encadenamiento para usar múltiples métodos de Active Record juntos. Cómo verificar la existencia de registros particulares. Cómo realizar varios cálculos en modelos de Active Record. Cómo ejecutar EXPLAIN en relaciones." />
  <meta property="og:description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Interfaz de Consulta de Active RecordEste guía cubre diferentes formas de recuperar datos de la base de datos utilizando Active Record.Después de leer esta guía, sabrás: Cómo encontrar registros utilizando una variedad de métodos y condiciones. Cómo especificar el orden, los atributos recuperados, la agrupación y otras propiedades de los registros encontrados. Cómo utilizar la carga ansiosa (eager loading) para reducir la cantidad de consultas a la base de datos necesarias para la recuperación de datos. Cómo usar los métodos de buscador dinámico. Cómo usar el método de encadenamiento para usar múltiples métodos de Active Record juntos. Cómo verificar la existencia de registros particulares. Cómo realizar varios cálculos en modelos de Active Record. Cómo ejecutar EXPLAIN en relaciones." />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
<!--    <img src="images/edge_badge.png" alt="edge-badge" id="edge-badge" />-->
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">Más en <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        Más Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">Blog</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">Guías</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://stackoverflow.com/questions/tagged/ruby-on-rails">Pedir Ayuda</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Contribuir on GitHub</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Guías de Ruby on Rails">Guías de Ruby on Rails </a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">Inicio</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Index de Guías </a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>Empieza Aqui</dt>
                  <dd><a href="getting_started.html">Introducción a Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Modelos</dt>
                  <dd><a href="active_record_basics.html">Conceptos básicos de Active Record</a></dd>
                  <dd><a href="active_record_migrations.html">Migraciones de Active Record</a></dd>
                  <dd><a href="active_record_validations.html">Validaciones de Active Record</a></dd>
                  <dd><a href="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</a></dd>
                  <dd><a href="association_basics.html">Asociaciones de Active Record</a></dd>
                  <dd><a href="active_record_querying.html">Interfaz de Consulta de Active Record</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Vistas</dt>
                  <dd><a href="layouts_and_rendering.html">Diseños y Renderizado en Rails</a></dd>
                  <dd><a href="form_helpers.html">Ayudantes de Formulario de Action</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controladores</dt>
                  <dd><a href="action_controller_overview.html">Descripción General de Action Controller</a></dd>
                  <dd><a href="routing.html">Rails Routing Desde el Exterior Hacia Adentro</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Otros Componentes</dt>
                  <dd><a href="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</a></dd>
                  <dd><a href="action_mailer_basics.html">Conceptos Básicos de Action Mailer</a></dd>
                  <dd><a href="active_job_basics.html">Conceptos Básicos de Active Job</a></dd>
                  <dd><a href="active_storage_overview.html">Descripción General de Active Storage</a></dd>
                  <dd><a href="action_cable_overview.html">Descripción General de Action Cable</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Temas Avanzados</dt>
                  <dd><a href="i18n.html">Rails API de Internacionalización (I18n)</a></dd>
                  <dd><a href="testing.html">Prueba de Aplicaciones de Rails</a></dd>
                  <dd><a href="security.html">Seguridad de Aplicaciones Rails</a></dd>
                  <dd><a href="debugging_rails_applications.html">Depuración de Applications Rails</a></dd>
                  <dd><a href="configuring.html">Configuración de Aplicaciones de Rails</a></dd>
                  <dd><a href="command_line.html">La Línea de Comandos de Rails</a></dd>
                  <dd><a href="asset_pipeline.html">La Canalización de Activos (necesita traducción)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode) (necesita traducción)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode) (necesita traducción)</a></dd>
                  <dd><a href="caching_with_rails.html">Caching with Rails An Overview (necesita traducción)</a></dd>
                  <dd><a href="api_app.html">Using Rails for API-only Applications (necesita traducción)</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Extending Rails  (toda la sección necesita traducción)</dt>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                </div>
            </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">Contribuir</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guides Index</option>
              <optgroup label="Empieza Aqui">
                  <option value="getting_started.html">Introducción a Rails</option>
              </optgroup>
              <optgroup label="Modelos">
                  <option value="active_record_basics.html">Conceptos básicos de Active Record</option>
                  <option value="active_record_migrations.html">Migraciones de Active Record</option>
                  <option value="active_record_validations.html">Validaciones de Active Record</option>
                  <option value="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</option>
                  <option value="association_basics.html">Asociaciones de Active Record</option>
                  <option value="active_record_querying.html">Interfaz de Consulta de Active Record</option>
              </optgroup>
              <optgroup label="Vistas">
                  <option value="layouts_and_rendering.html">Diseños y Renderizado en Rails</option>
                  <option value="form_helpers.html">Ayudantes de Formulario de Action</option>
              </optgroup>
              <optgroup label="Controladores">
                  <option value="action_controller_overview.html">Descripción General de Action Controller</option>
                  <option value="routing.html">Rails Routing Desde el Exterior Hacia Adentro</option>
              </optgroup>
              <optgroup label="Otros Componentes">
                  <option value="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</option>
                  <option value="action_mailer_basics.html">Conceptos Básicos de Action Mailer</option>
                  <option value="active_job_basics.html">Conceptos Básicos de Active Job</option>
                  <option value="active_storage_overview.html">Descripción General de Active Storage</option>
                  <option value="action_cable_overview.html">Descripción General de Action Cable</option>
              </optgroup>
              <optgroup label="Temas Avanzados">
                  <option value="i18n.html">Rails API de Internacionalización (I18n)</option>
                  <option value="testing.html">Prueba de Aplicaciones de Rails</option>
                  <option value="security.html">Seguridad de Aplicaciones Rails</option>
                  <option value="debugging_rails_applications.html">Depuración de Applications Rails</option>
                  <option value="configuring.html">Configuración de Aplicaciones de Rails</option>
                  <option value="command_line.html">La Línea de Comandos de Rails</option>
                  <option value="asset_pipeline.html">La Canalización de Activos (necesita traducción)</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode) (necesita traducción)</option>
                  <option value="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode) (necesita traducción)</option>
                  <option value="caching_with_rails.html">Caching with Rails An Overview (necesita traducción)</option>
                  <option value="api_app.html">Using Rails for API-only Applications (necesita traducción)</option>
              </optgroup>
              <optgroup label="Extending Rails  (toda la sección necesita traducción)">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <p><strong>NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p><h2>Interfaz de Consulta de Active Record</h2><p>Este guía cubre diferentes formas de recuperar datos de la base de datos utilizando Active Record.</p><p>Después de leer esta guía, sabrás:</p>
<ul>
<li>Cómo encontrar registros utilizando una variedad de métodos y condiciones.</li>
<li>Cómo especificar el orden, los atributos recuperados, la agrupación y otras propiedades de los registros encontrados.</li>
<li>Cómo utilizar la carga ansiosa (eager loading) para reducir la cantidad de consultas a la base de datos necesarias para la recuperación de datos.</li>
<li>Cómo usar los métodos de buscador dinámico.</li>
<li>Cómo usar el método de encadenamiento para usar múltiples métodos de Active Record juntos.</li>
<li>Cómo verificar la existencia de registros particulares.</li>
<li>Cómo realizar varios cálculos en modelos de Active Record.</li>
<li>Cómo ejecutar EXPLAIN en relaciones.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#what-is-the-active-record-query-interface-questionmark">What is the Active Record Query Interface?</a></li>
<li>
<a href="#retrieving-objects-from-the-database">Retrieving Objects from the Database</a>

<ul>
<li><a href="#retrieving-a-single-object">Retrieving a Single Object</a></li>
<li><a href="#retrieving-multiple-objects-in-batches">Retrieving Multiple Objects in Batches</a></li>
</ul>
</li>
<li>
<a href="#conditions">Conditions</a>

<ul>
<li><a href="#pure-string-conditions">Pure String Conditions</a></li>
<li><a href="#array-conditions">Array Conditions</a></li>
<li><a href="#hash-conditions">Hash Conditions</a></li>
<li><a href="#not-conditions">NOT Conditions</a></li>
<li><a href="#or-conditions">OR Conditions</a></li>
</ul>
</li>
<li><a href="#ordering">Ordering</a></li>
<li><a href="#selecting-specific-fields">Selecting Specific Fields</a></li>
<li><a href="#limit-and-offset">Limit and Offset</a></li>
<li>
<a href="#group">Group</a>

<ul>
<li><a href="#total-of-grouped-items">Total of grouped items</a></li>
</ul>
</li>
<li><a href="#having">Having</a></li>
<li>
<a href="#overriding-conditions">Overriding Conditions</a>

<ul>
<li><a href="#unscope"><code>unscope</code></a></li>
<li><a href="#only"><code>only</code></a></li>
<li><a href="#reselect"><code>reselect</code></a></li>
<li><a href="#reorder"><code>reorder</code></a></li>
<li><a href="#reverse-order"><code>reverse_order</code></a></li>
<li><a href="#rewhere"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#null-relation">Null Relation</a></li>
<li><a href="#readonly-objects">Readonly Objects</a></li>
<li>
<a href="#locking-records-for-update">Locking Records for Update</a>

<ul>
<li><a href="#optimistic-locking">Optimistic Locking</a></li>
<li><a href="#pessimistic-lockin">Pessimistic Lockin</a></li>
</ul>
</li>
<li>
<a href="#joining-tables">Joining Tables</a>

<ul>
<li><a href="#une"><code>une</code></a></li>
<li><a href="#left-outer-joins"><code>left_outer_joins</code></a></li>
</ul>
</li>
<li>
<a href="#eager-loading-associations">Eager Loading Associations</a>

<ul>
<li><a href="#eager-loading-multiple-associations">Eager Loading Multiple Associations</a></li>
<li><a href="#specifying-conditions-on-eager-loaded-associations">Specifying Conditions on Eager Loaded Associations</a></li>
</ul>
</li>
<li>
<a href="#scopes">Scopes</a>

<ul>
<li><a href="#passing-in-arguments">Passing in arguments</a></li>
<li><a href="#using-conditionals">Using conditionals</a></li>
<li><a href="#applying-a-default-scope">Applying a default scope</a></li>
<li><a href="#merging-of-scopes">Merging of scopes</a></li>
<li><a href="#removing-all-scoping">Removing All Scoping</a></li>
</ul>
</li>
<li><a href="#dynamic-finders">Dynamic Finders</a></li>
<li><a href="#enums">Enums</a></li>
<li>
<a href="#understanding-the-method-chaining">Understanding The Method Chaining</a>

<ul>
<li><a href="#retrieving-filtered-data-from-multiple-tables">Retrieving filtered data from multiple tables</a></li>
<li><a href="#retrieving-specific-data-from-multiple-tables">Retrieving specific data from multiple tables</a></li>
</ul>
</li>
<li>
<a href="#find-or-build-a-new-object">Find or Build a New Object</a>

<ul>
<li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li>
<li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li>
<li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#finding-by-sql">Finding by SQL</a>

<ul>
<li><a href="#select-all"><code>select_all</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#ids"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#existence-of-objects">Existence of Objects</a></li>
<li>
<a href="#calculations">Calculations</a>

<ul>
<li><a href="#count">Count</a></li>
<li><a href="#average">Average</a></li>
<li><a href="#minimum">Minimum</a></li>
<li><a href="#maximum">Maximum</a></li>
<li><a href="#sum">Sum</a></li>
</ul>
</li>
<li>
<a href="#running-explain">Running EXPLAIN</a>

<ul>
<li><a href="#interpreting-explain">Interpreting EXPLAIN</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="what-is-the-active-record-query-interface-questionmark"><a class="anchorlink" href="#what-is-the-active-record-query-interface-questionmark">1 What is the Active Record Query Interface?</a></h3><p>¿Qué es la interfaz de consulta de Active Record?</p><p>Si está acostumbrado a usar SQL sin procesar para buscar registros de bases de datos, generalmente encontrarás que hay mejores formas de llevar a cabo las mismas operaciones en Rails. Active Record lo aísla de la necesidad de usar SQL en la mayoría de los casos.</p><p>Active Record realizará consultas en la base de datos por usted y es compatible con la mayoría de los sistemas de bases de datos, incluidos MySQL, MariaDB, PostgreSQL y SQLite. Independientemente del sistema de base de datos que esté utilizando, el formato del método Active Record siempre será el mismo.</p><p>Los ejemplos de código a lo largo de esta guía se referirán a uno o más de los siguientes modelos:</p><p>SUGERENCIA: Todos los siguientes modelos usan <code>id</code> como su clave principal, a menos que se especifique lo contrario.</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby">class Address &lt; ApplicationRecord
  belongs_to :client
end
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  belongs_to :client, counter_cache: true
end
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby">class Role &lt; ApplicationRecord
  has_and_belongs_to_many :clients
end
</code></pre>
</div>
<h3 id="retrieving-objects-from-the-database"><a class="anchorlink" href="#retrieving-objects-from-the-database">2 Retrieving Objects from the Database</a></h3><p>Recuperando objetos de la base de datos</p><p>Para recuperar objetos de la base de datos, Active Record proporciona varios métodos de búsqueda. Cada método de búsqueda le permite pasar argumentos para realizar ciertas consultas en su base de datos sin escribir SQL sin formato.</p><p>Los métodos son:</p>
<ul>
<li><code>annotate</code></li>
<li><code>find</code></li>
<li><code>create_with</code></li>
<li><code>distinct</code></li>
<li><code>eager_load</code></li>
<li><code>extending</code></li>
<li><code>extract_associated</code></li>
<li><code>from</code></li>
<li><code>group</code></li>
<li><code>having</code></li>
<li><code>includes</code></li>
<li><code>joins</code></li>
<li><code>left_outer_joins</code></li>
<li><code>limit</code></li>
<li><code>lock</code></li>
<li><code>none</code></li>
<li><code>offset</code></li>
<li><code>optimizer_hints</code></li>
<li><code>order</code></li>
<li><code>preload</code></li>
<li><code>readonly</code></li>
<li><code>references</code></li>
<li><code>reorder</code></li>
<li><code>reselect</code></li>
<li><code>reverse_order</code></li>
<li><code>select</code></li>
<li><code>where</code></li>
</ul>
<p>Los métodos de búsqueda que devuelven una colección, como <code>where</code> y <code>group</code>, devuelven una instancia de <code>ActiveRecord::Relation</code>. Los métodos que encuentran una sola entidad, como <code>find</code> y <code>first</code>, devuelven una sola instancia del modelo.</p><p>La operación principal de <code>Model.find(options)</code> se puede resumir como:</p>
<ul>
<li>Convierta las opciones proporcionadas a una consulta equivalente en SQL.</li>
<li>Active la consulta SQL y recupere los resultados correspondientes de la base de datos.</li>
<li>Instanciar el objeto Ruby equivalente del modelo apropiado para cada fila en los resultados.</li>
<li>Ejecute <code>after_find</code> y luego <code>after_initialize</code> callbacks, si corresponde.</li>
</ul>
<h4 id="retrieving-a-single-object"><a class="anchorlink" href="#retrieving-a-single-object">2.1 Retrieving a Single Object</a></h4><p>Recuperando un Solo Objeto</p><p>Active Record proporciona varias formas diferentes de recuperar un solo objeto.</p><h5 id="find"><a class="anchorlink" href="#find">2.1.1 <code>find</code></a></h5><p>Usando el método <code>find</code>, puede recuperar el objeto correspondiente a la <em>primary key</em> especificada que coincide con las opciones proporcionadas. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby"># Find the client with primary key (id) 10.
client = Client.find(10)
# =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
</code></pre>
</div>
<p>El método <code>find</code> generará una excepción <code>ActiveRecord::RecordNotFound</code> si no se encuentra un registro coincidente.</p><div class="code_container">
<pre><code class="language-ruby"># Find the clients with primary keys 1 and 10.
clients = Client.find([1, 10]) # Or even Client.find(1, 10)
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.id IN (1,10))
</code></pre>
</div>
<p>ADVERTENCIA: El método <code>find</code> generará una excepción <code>ActiveRecord::RecordNotFound</code> a menos que se encuentre un registro coincidente para <em>all</em>* (todas) de las claves principales proporcionadas.</p><h5 id="take"><a class="anchorlink" href="#take">2.1.2 <code>take</code></a></h5><p>El método <code>take</code> recupera un registro sin ningún orden implícito. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">client = Client.take
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients LIMIT 1
</code></pre>
</div>
<p>El método <code>take</code> devuelve <code>nil</code> si no se encuentra ningún registro y no se generará ninguna excepción.</p><p>Puede pasar un argumento numérico al método <code>take</code> para obtener ese número de resultados. Por ejemplo</p><div class="code_container">
<pre><code class="language-ruby">clients = Client.take(2)
# =&gt; [
#   #&lt;Client id: 1, first_name: "Lifo"&gt;,
#   #&lt;Client id: 220, first_name: "Sara"&gt;
# ]
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients LIMIT 2
</code></pre>
</div>
<p>El método <code>take!</code> se comporta exactamente como <code>take</code>, excepto que generará <code>ActiveRecord::RecordNotFound</code> si no se encuentra un registro coincidente.</p><p>SUGERENCIA: El registro recuperado puede variar según el motor de la base de datos.</p><h5 id="first"><a class="anchorlink" href="#first">2.1.3 <code>first</code></a></h5><p>El método <code>first</code> encuentra el primer registro ordenado por clave primaria (predeterminado). Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">client = Client.first
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
</code></pre>
</div>
<p>El método <code>first</code> devuelve <code>nil</code> si no se encuentra un registro coincidente y no se generará ninguna excepción.</p><p>Si su <a href="active_record_querying.html#applying-a-default-scope">alcance predeterminado</a> contiene un método de pedido, <code>first</code> devolverá el primer registro de acuerdo con este pedido.</p><p>Puede pasar un argumento numérico al método <code>first</code> para obtener ese número de resultados. Por ejemplo</p><div class="code_container">
<pre><code class="language-ruby">clients = Client.first(3)
# =&gt; [
#   #&lt;Client id: 1, first_name: "Lifo"&gt;,
#   #&lt;Client id: 2, first_name: "Fifo"&gt;,
#   #&lt;Client id: 3, first_name: "Filo"&gt;
# ]
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
</code></pre>
</div>
<p>En una colección que se ordena usando <code>order</code>, <code>first</code> devolverá el primer registro ordenado por el atributo especificado en <code>order</code>.</p><div class="code_container">
<pre><code class="language-ruby">client = Client.order(:first_name).first
# =&gt; #&lt;Client id: 2, first_name: "Fifo"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
</code></pre>
</div>
<p>El método <code>first!</code> se comporta exactamente como <code>first</code>, excepto que generará <code>ActiveRecord::RecordNotFound</code> si no se encuentra un registro coincidente.</p><h5 id="last"><a class="anchorlink" href="#last">2.1.4 <code>last</code></a></h5><p>El método <code>last</code> encuentra el último registro ordenado por clave primaria (predeterminado). Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">client = Client.last
# =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</code></pre>
</div>
<p>El método <code>last</code> devuelve <code>nil</code> si no se encuentra un registro coincidente y no se generará ninguna excepción.</p><p>Si su <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contiene un método de pedido, <code>last</code> devolverá el último registro de acuerdo con este pedido.</p><p>You can pass in a numerical argument to the <code>last</code> method to return up to that number of results. For example</p><div class="code_container">
<pre><code class="language-ruby">clients = Client.last(3)
# =&gt; [
#   #&lt;Client id: 219, first_name: "James"&gt;,
#   #&lt;Client id: 220, first_name: "Sara"&gt;,
#   #&lt;Client id: 221, first_name: "Russel"&gt;
# ]
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
</code></pre>
</div>
<p>En una colección que se ordena usando <code>order</code>, <code>last</code> devolverá el último registro ordenado por el atributo especificado para <code>order</code>.</p><div class="code_container">
<pre><code class="language-ruby">client = Client.order(:first_name).last
# =&gt; #&lt;Client id: 220, first_name: "Sara"&gt;
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
</code></pre>
</div>
<p>El método <code>last!</code> Se comporta exactamente como <code>last</code>, excepto que generará <code>ActiveRecord::RecordNotFound</code> si no se encuentra un registro coincidente.</p><h5 id="find-by"><a class="anchorlink" href="#find-by">2.1.5 <code>find_by</code></a></h5><p>El método <code>find_by</code> encuentra el primer registro que coincide con algunas condiciones. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_by first_name: 'Lifo'
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

Client.find_by first_name: 'Jon'
# =&gt; nil
</code></pre>
</div>
<p>Es equivalente a escribir:</p><div class="code_container">
<pre><code class="language-ruby">Client.where(first_name: 'Lifo').take
</code></pre>
</div>
<p>El SQL equivalente de lo anterior es:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
</code></pre>
</div>
<p>El método <code>find_by!</code> Se comporta exactamente igual que <code>find_by</code>, excepto que generará <code>ActiveRecord::RecordNotFound</code> si no se encuentra un registro coincidente. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_by! first_name: 'does not exist'
# =&gt; ActiveRecord::RecordNotFound
</code></pre>
</div>
<p>Es equivalente a escribir:</p><div class="code_container">
<pre><code class="language-ruby">Client.where(first_name: 'does not exist').take!
</code></pre>
</div>
<h4 id="retrieving-multiple-objects-in-batches"><a class="anchorlink" href="#retrieving-multiple-objects-in-batches">2.2 Retrieving Multiple Objects in Batches</a></h4><p>Recuperando múltiples objetos en lotes</p><p>A menudo necesitamos iterar sobre un gran conjunto de registros, como cuando enviamos un boletín a un gran conjunto de usuarios, o cuando exportamos datos.</p><p>Esto puede parecer sencillo:</p><div class="code_container">
<pre><code class="language-ruby"># This may consume too much memory if the table is big.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p>Pero este enfoque se vuelve cada vez menos práctico a medida que aumenta el tamaño de la tabla, ya que <code>User.all.each</code> instruye a Active Record a buscar <em>the entire table</em>  (la tabla completa) en una sola pasada, construir un objeto modelo por fila y luego mantener toda la matriz de objetos modelo en memoria. De hecho, si tenemos una gran cantidad de registros, la colección completa puede exceder la cantidad de memoria disponible.</p><p>Rails proporciona dos métodos que abordan este problema dividiendo los registros en lotes amigables para el procesamiento. El primer método, <code>find_each</code>, recupera un lote de registros y luego entrega <em>each</em> cada uno de los registros al bloque individualmente como modelo. El segundo método, <code>find_in_batches</code>, recupera un lote de registros y luego entrega <em>the entire batch</em> al bloque como una matriz de modelos.</p><p>SUGERENCIA: Los métodos <code>find_each</code> y <code>find_in_batches</code> están diseñados para usarse en el procesamiento por lotes de una gran cantidad de registros que no caben en la memoria de una vez. Si solo necesita recorrer más de mil registros, los métodos de búsqueda regulares son la opción preferida.</p><h5 id="find-each"><a class="anchorlink" href="#find-each">2.2.1 <code>find_each</code></a></h5><p>El método <code>find_each</code> recupera registros en lotes y luego arroja <em>each</em> (cada uno) al bloque. En el siguiente ejemplo, <code>find_each</code> recupera usuarios en lotes de 1000 y los entrega al bloque uno por uno:</p><div class="code_container">
<pre><code class="language-ruby">User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p>Este proceso se repite, obteniendo más lotes según sea necesario, hasta que se hayan procesado todos los registros.</p><p><code>find_each</code> funciona en clases de modelos, como se ve arriba, y también en relaciones:</p><div class="code_container">
<pre><code class="language-ruby">User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p>siempre que no tengan orden, ya que el método necesita forzar una orden
internamente para iterar.</p><p>Si hay una orden presente en el receptor, el comportamiento depende de la bandera
<code>config.active_record.error_on_ignored_order</code>. Si es true (verdadero), el <code>ArgumentError</code> es
elevado, de lo contrario se ignora la orden y se emite una advertencia, que es el
defecto. Esto se puede anular con la opción <code>:error_on_ignore</code>, explicada
abajo.</p><h6 id="options-for-find-each"><a class="anchorlink" href="#options-for-find-each">2.2.1.1 Options for <code>find_each</code></a></h6><p><strong><code>:batch_size</code></strong></p><p>La opción <code>:batch_size</code> le permite especificar el número de registros que se recuperarán en cada lote, antes de pasarlos individualmente al bloque. Por ejemplo, para recuperar registros en lotes de 5000:</p><div class="code_container">
<pre><code class="language-ruby">User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p><strong><code>:start</code></strong></p><p>De forma predeterminada, los registros se obtienen en orden ascendente de la clave primaria. La opción <code>:start</code> le permite configurar la primera ID de la secuencia siempre que la ID más baja no sea la que necesita. Esto sería útil, por ejemplo, si desea reanudar un proceso por lotes interrumpido, siempre que haya guardado la última ID procesada como un punto de control.</p><p>Por ejemplo, para enviar boletines solo a usuarios con la clave principal a partir de 2000:</p><div class="code_container">
<pre><code class="language-ruby">User.find_each(start: 2000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p><strong><code>:finish</code></strong></p><p>Similar a la opción <code>:start</code>,<code>:finish</code> le permite configurar la última ID de la secuencia siempre que la ID más alta no sea la que necesita.</p><p>Esto sería útil, por ejemplo, si desea ejecutar un proceso por lotes utilizando un subconjunto de registros basados ​​en <code>:inicio</code> y <code>:finalización</code>.</p><p>Por ejemplo, para enviar boletines solo a usuarios con la clave principal a partir de 2000 hasta 10000:</p><div class="code_container">
<pre><code class="language-ruby">User.find_each(start: 2000, finish: 10000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</code></pre>
</div>
<p>Otro ejemplo sería si quisieras que varios trabajadores manejan la misma
cola de procesamiento. Puede hacer que cada trabajador maneje 10000 registros configurando
opciones apropiadas de <code>:start</code> y<code>:finish</code> para cada trabajador.</p><p><strong><code>:error_on_ignore</code></strong></p><p>Invalida la configuración de la aplicación para especificar si se debe generar un error cuando un
orden este presente en la relación.</p><h5 id="find-in-batches"><a class="anchorlink" href="#find-in-batches">2.2.2 <code>find_in_batches</code></a></h5><p>El método <code>find_in_batches</code> es similar a <code>find_each</code>, ya que ambos recuperan lotes de registros. La diferencia es que <code>find_in_batches</code> produce <em>batches</em> para el bloque como una matriz de modelos, en lugar de individualmente. El siguiente ejemplo le dará al bloque suministrado una matriz de hasta 1000 facturas a la vez, con el bloque final que contiene las facturas restantes:</p><div class="code_container">
<pre><code class="language-ruby"># Give add_invoices an array of 1000 invoices at a time.
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
</code></pre>
</div>
<p><code>find_in_batches</code> funciona en clases de modelos, como se ve arriba, y también en relaciones:</p><div class="code_container">
<pre><code class="language-ruby">Invoice.pending.find_in_batches do |invoices|
  pending_invoices_export.add_invoices(invoices)
end
</code></pre>
</div>
<p>siempre que no tengan un ordern, ya que el método necesita forzar un orden
internamente para iterar.</p><h6 id="opciones-para-find-in-batches"><a class="anchorlink" href="#opciones-para-find-in-batches">2.2.2.1 Opciones para <code>find_in_batches</code></a></h6><p>El método <code>find_in_batches</code> acepta las mismas opciones que <code>find_each</code>:</p><p><strong><code>:batch_size</code></strong></p><p>Al igual que para <code>find_each</code>, <code>batch_size</code> establece cuántos registros se recuperarán en cada grupo. Por ejemplo, la recuperación de lotes de 2500 registros se puede especificar como:</p><div class="code_container">
<pre><code class="language-ruby">Invoice.find_in_batches(batch_size: 2500) do |invoices|
  export.add_invoices(invoices)
end
</code></pre>
</div>
<p><strong><code>:start</code></strong></p><p>La opción <code>start</code> permite especificar la ID inicial desde donde se seleccionarán los registros. Como se mencionó anteriormente, por defecto los registros se obtienen en orden ascendente de la clave primaria. Por ejemplo, para recuperar facturas que comienzan en ID: 5000 en lotes de 2500 registros, se puede usar el siguiente código:</p><div class="code_container">
<pre><code class="language-ruby">Invoice.find_in_batches(finish: 7000) do |invoices|
  export.add_invoices(invoices)
end
</code></pre>
</div>
<p><strong><code>:error_on_ignore</code></strong></p><p>La opción <code>error_on_ignore</code> anula la configuración de la aplicación para especificar si se debe generar un error cuando hay un orden específico en la relación.</p><h3 id="conditions"><a class="anchorlink" href="#conditions">3 Conditions</a></h3><p>Condiciones</p><p>El método <code>where</code> le permite especificar condiciones para limitar los registros devueltos, representando la parte<code>WHERE</code> de la instrucción SQL. Las condiciones se pueden especificar como una cadena, matriz o hash.</p><h4 id="pure-string-conditions"><a class="anchorlink" href="#pure-string-conditions">3.1 Pure String Conditions</a></h4><p>Condiciones de cadena pura</p><p>Si desea agregar condiciones a su búsqueda, puede especificarlas allí, como <code>Client.where ("orders_count = '2'")</code>. Esto encontrará a todos los clientes donde el valor del campo <code>orders_count</code> es 2.</p><p>ADVERTENCIA: Construir sus propias condiciones como cadenas puras puede dejarlo vulnerable a los ataques de inyección SQL. Por ejemplo, <code>Client.where("first_name LIKE '%#{params[:first_name]}%'")</code> no es seguro. Consulte la siguiente sección para conocer la forma preferida de manejar las condiciones utilizando una matriz.</p><h4 id="array-conditions"><a class="anchorlink" href="#array-conditions">3.2 Array Conditions</a></h4><p>Condiciones de la matriz</p><p>Ahora, ¿qué pasa si ese número puede variar, digamos como un argumento desde algún lugar? El hallazgo entonces tomaría la forma:</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count = ?", params[:orders])
</code></pre>
</div>
<p>Active Record tomará el primer argumento como la cadena de condiciones y cualquier argumento adicional reemplazará los signos de interrogación <code>(?)</code> en él.</p><p>Si desea especificar condiciones múltiples:</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count = ? AND locked = ?", params[:orders], false)
</code></pre>
</div>
<p>En este ejemplo, el primer signo de interrogación se reemplazará con el valor en <code>params[:orders]</code> y el segundo se reemplazará con la representación SQL de <code>false</code>, que depende del adaptador.</p><p>Este código es altamente preferible:</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count = ?", params[:orders])
</code></pre>
</div>
<p>a este código:</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count = #{params[:orders]}")
</code></pre>
</div>
<p>por razones de seguridad. Poner la variable directamente en la cadena de condiciones pasará la variable a la base de datos <strong>as-is</strong> (tal cual). Esto significa que será una variable sin escape directamente de un usuario que pueda tener intenciones maliciosas. Si hace esto, pone en riesgo toda su base de datos porque una vez que un usuario se entera de que puede explotar su base de datos, puede hacer casi cualquier cosa. Nunca ponga sus argumentos directamente dentro de la cadena de condiciones.</p><p>SUGERENCIA: Para obtener más información sobre los peligros de la inyección SQL, consulte la publicación <a href="security.html#sql-injection">Ruby on Rails Security Guide</a>.</p><h5 id="placeholder-conditions"><a class="anchorlink" href="#placeholder-conditions">3.2.1 Placeholder Conditions</a></h5><p>Similar al estilo de reemplazo de  como (<code>?)</code>, también se puede especificar claves en la cadena de condiciones junto con un hash de claves/valores correspondiente:</p><div class="code_container">
<pre><code class="language-ruby">Client.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
</code></pre>
</div>
<p>Esto permite una legibilidad más clara si tiene una gran cantidad de condiciones variables.</p><h4 id="hash-conditions"><a class="anchorlink" href="#hash-conditions">3.3 Hash Conditions</a></h4><p>Condiciones de hash</p><p>Active Record también le permite pasar en condiciones hash que pueden aumentar la legibilidad de la sintaxis de sus condiciones. Con condiciones hash, pasa un hash con las claves de los campos que desea calificar y los valores de cómo desea calificarlos:</p><p>NOTA: Solo es posible la verificación de igualdad, rango y subconjunto con condiciones Hash.</p><h5 id="equality-conditions"><a class="anchorlink" href="#equality-conditions">3.3.1 Equality Conditions</a></h5><p>Condiciones de igualdad</p><div class="code_container">
<pre><code class="language-ruby">Client.where(locked: true)
</code></pre>
</div>
<p>Esto generará SQL como este:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.locked = 1)
</code></pre>
</div>
<p>El nombre del campo también puede ser una cadena:</p><div class="code_container">
<pre><code class="language-ruby">Client.where('locked' =&gt; true)
</code></pre>
</div>
<p>En el caso de una relación belong_to, se puede usar una asociación de clave para especificar el modelo si se usa un objeto Active Record como valor. Este método también funciona con relaciones polimórficas.</p><div class="code_container">
<pre><code class="language-ruby">Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
</code></pre>
</div>
<h5 id="range-conditions"><a class="anchorlink" href="#range-conditions">3.3.2 Range Conditions</a></h5><p>Condiciones de rango</p><div class="code_container">
<pre><code class="language-ruby">Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
</code></pre>
</div>
<p>Esto encontrará todos los clientes creados ayer mediante el uso de una instrucción SQL <code>BETWEEN</code></p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
</code></pre>
</div>
<p>Esto demuestra una sintaxis más corta para los ejemplos en <a href="#array-conditions">Array Conditions</a></p><h5 id="subset-conditions"><a class="anchorlink" href="#subset-conditions">3.3.3 Subset Conditions</a></h5><p>Condiciones de subconjunto</p><p>Si desea buscar registros utilizando la expresión <code>IN</code>, puede pasar una matriz a las condiciones hash:</p><div class="code_container">
<pre><code class="language-ruby">Client.where(orders_count: [1,3,5])
</code></pre>
</div>
<p>Este código generará SQL así:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
</code></pre>
</div>
<h4 id="not-conditions"><a class="anchorlink" href="#not-conditions">3.4 NOT Conditions</a></h4><p>Condiciones NOT</p><p><code>NOT</code> SQL queries can be built by <code>where.not</code>:</p><div class="code_container">
<pre><code class="language-ruby">Client.where.not(locked: true)
</code></pre>
</div>
<p>En otras palabras, esta consulta se puede generar llamando a <code>where</code> sin argumento, e inmediatamente encadenando con<code>not</code> pasando <code>where</code> condiciones. Esto generará SQL como este:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.locked != 1)
</code></pre>
</div>
<h4 id="or-conditions"><a class="anchorlink" href="#or-conditions">3.5 OR Conditions</a></h4><p>Condiciones OR</p><p>Las condiciones <code>OR</code> entre dos relaciones se pueden construir llamando a <code>o</code> en la primera
relación, y pasando el segundo como argumento.</p><div class="code_container">
<pre><code class="language-ruby">Client.where(locked: true).or(Client.where(orders_count: [1,3,5]))
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.locked = 1 OR clients.orders_count IN (1,3,5))
</code></pre>
</div>
<h3 id="ordering"><a class="anchorlink" href="#ordering">4 Ordering</a></h3><p>Ordenar</p><p>Para recuperar registros de la base de datos en un orden específico, puede usar el método <code>order</code>.</p><p>Por ejemplo, si obtiene un conjunto de registros y desea ordenarlos en orden ascendente por el campo <code>created_at</code> de su tabla:</p><div class="code_container">
<pre><code class="language-ruby">Client.order(:created_at)
# OR
Client.order("created_at")
</code></pre>
</div>
<p>También se puede especificar <code>ASC</code> o<code>DESC</code>:</p><div class="code_container">
<pre><code class="language-ruby">Client.order(created_at: :desc)
# OR
Client.order(created_at: :asc)
# OR
Client.order("created_at DESC")
# OR
Client.order("created_at ASC")
</code></pre>
</div>
<p>O ordenando por múltiples campos:</p><div class="code_container">
<pre><code class="language-ruby">Client.order(orders_count: :asc, created_at: :desc)
# OR
Client.order(:orders_count, created_at: :desc)
# OR
Client.order("orders_count ASC, created_at DESC")
# OR
Client.order("orders_count ASC", "created_at DESC")
</code></pre>
</div>
<p>Si desea llamar a <code>order</code> varias veces, los pedidos posteriores se agregarán al primero:</p><div class="code_container">
<pre><code class="language-ruby">Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
</code></pre>
</div>
<p>ADVERTENCIA: En la mayoría de los sistemas de bases de datos, al seleccionar campos con <code>distinct</code> de un conjunto de resultados utilizando métodos como <code>select</code>, <code>pluck</code> e <code>ids</code>; el método <code>order</code> generará una excepción <code>ActiveRecord::StatementInvalid</code> a menos que los campos utilizados en la cláusula <code>order</code> se incluyan en la lista de selección. Consulte la siguiente sección para seleccionar campos del conjunto de resultados.</p><h3 id="selecting-specific-fields"><a class="anchorlink" href="#selecting-specific-fields">5 Selecting Specific Fields</a></h3><p>Seleccionar campos específicos</p><p>Por defecto, <code>Model.find</code> selecciona todos los campos del conjunto de resultados usando <code>select *</code>.</p><p>Para seleccionar solo un subconjunto de campos del conjunto de resultados, puede especificar el subconjunto mediante el método <code>select</code>.</p><p>Por ejemplo, para seleccionar solo columnas <code>viewable_by</code> y<code>bloqueadas</code>:</p><div class="code_container">
<pre><code class="language-ruby">Client.select(:viewable_by, :locked)
# OR
Client.select("viewable_by, locked")
</code></pre>
</div>
<p>La consulta SQL utilizada por esta llamada de búsqueda será algo así como:</p><div class="code_container">
<pre><code class="language-sql">SELECT viewable_by, locked FROM clients
</code></pre>
</div>
<p>Tenga cuidado porque esto también significa que está inicializando un objeto modelo con solo los campos que haz seleccionado. Si intenta acceder a un campo que no está en el registro inicializado, recibirá:</p><div class="code_container">
<pre><code class="language-shell-session">ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;
</code></pre>
</div>
<p>Donde <code>&lt;attribute&gt;</code> es el atributo que solicitó. El método <code>id</code> no generará el <code>ActiveRecord::MissingAttributeError</code>, así que tenga cuidado al trabajar con asociaciones porque necesitan el método <code>id</code> para funcionar correctamente.</p><p>Si desea obtener solo un registro por valor único en un campo determinado, puede usar <code>distinct</code>:</p><div class="code_container">
<pre><code class="language-ruby">Client.select(:name).distinct
</code></pre>
</div>
<p>Esto generaría SQL como:</p><div class="code_container">
<pre><code class="language-sql">SELECT DISTINCT name FROM clients
</code></pre>
</div>
<p>También puede eliminar la restricción de unicidad:</p><div class="code_container">
<pre><code class="language-ruby">query = Client.select(:name).distinct
# =&gt; Returns unique names

query.distinct(false)
# =&gt; Returns all names, even if there are duplicates
</code></pre>
</div>
<h3 id="limit-and-offset"><a class="anchorlink" href="#limit-and-offset">6 Limit and Offset</a></h3><p>Límite y compensación</p><p>Para aplicar <code>LIMIT</code> al SQL disparado por el<code>Model.find</code>, puede especificar el <code>LIMIT</code> usando los métodos <code>limit</code> y <code>offset</code> en la relación.</p><p>Puede usar <code>limit</code> para especificar el número de registros que se recuperarán, y usar <code>offset</code> para especificar el número de registros que se omitirán antes de comenzar a devolver los registros. Por ejemplo</p><div class="code_container">
<pre><code class="language-ruby">Client.limit(5)
</code></pre>
</div>
<p>devolverá un máximo de 5 clientes y dado que no especifica ningún desplazamiento, devolverá los primeros 5 de la tabla. El SQL que ejecuta se ve así:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients LIMIT 5
</code></pre>
</div>
<p>Añadiendo <code>offset</code> a eso</p><div class="code_container">
<pre><code class="language-ruby">Client.limit(5).offset(30)
</code></pre>
</div>
<p>devolverá en su lugar un máximo de 5 clientes a partir del 31. El SQL se ve así:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients LIMIT 5 OFFSET 30
</code></pre>
</div>
<h3 id="group"><a class="anchorlink" href="#group">7 Group</a></h3><p>Grupo</p><p>Para aplicar una cláusula <code>GROUP BY</code> al SQL disparado por el buscador, puede usar el método <code>group</code>.</p><p>Por ejemplo, si desea encontrar una colección de las fechas en que se crearon los pedidos:</p><div class="code_container">
<pre><code class="language-ruby">Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
</code></pre>
</div>
<p>Y esto le dará un único objeto <code>Order</code> para cada fecha en la que haya pedidos en la base de datos.</p><p>El SQL que se ejecutaría sería algo como esto:</p><div class="code_container">
<pre><code class="language-sql">SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
</code></pre>
</div>
<h4 id="total-of-grouped-items"><a class="anchorlink" href="#total-of-grouped-items">7.1 Total of grouped items</a></h4><p>Total de artículos agrupados</p><p>Para obtener el total de elementos agrupados en una sola consulta, llame a <code>count</code> después del <code>group</code>.</p><div class="code_container">
<pre><code class="language-ruby">Order.group(:status).count
# =&gt; { 'awaiting_approval' =&gt; 7, 'paid' =&gt; 12 }
</code></pre>
</div>
<p>El SQL que se ejecutaría sería algo como esto:</p><div class="code_container">
<pre><code class="language-sql">SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
</code></pre>
</div>
<h3 id="having"><a class="anchorlink" href="#having">8 Having</a></h3><p>SQL usa la cláusula <code>HAVING</code> para especificar condiciones en los campos <code>GROUP BY</code>. Puede agregar la cláusula <code>HAVING</code> al SQL disparado por el <code>Model.find</code> agregando el método <code>having</code> al hallazgo.</p><p>Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) &gt; ?", 100)
</code></pre>
</div>
<p>El SQL que se ejecutaría sería algo como esto:</p><div class="code_container">
<pre><code class="language-sql">SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) &gt; 100
</code></pre>
</div>
<p>Esto devuelve la fecha y el precio total de cada objeto de pedido, agrupados por el día en que se ordenaron y donde el precio es superior a $ 100.</p><h3 id="overriding-conditions"><a class="anchorlink" href="#overriding-conditions">9 Overriding Conditions</a></h3><p>Condiciones primordiales</p><h4 id="unscope"><a class="anchorlink" href="#unscope">9.1 <code>unscope</code></a></h4><p>Puede especificar ciertas condiciones que se eliminarán utilizando el método <code>unscope</code>. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Article.where('id &gt; 10').limit(20).order('id asc').unscope(:order)
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM articles WHERE id &gt; 10 LIMIT 20

# Original query without `unscope`
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id asc LIMIT 20

</code></pre>
</div>
<p>También puede desmarcar cláusulas específicas 'where'. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
</code></pre>
</div>
<p>Una relación que ha usado <code>unscope</code> afectará cualquier relación en la que se fusione:</p><div class="code_container">
<pre><code class="language-ruby">Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
</code></pre>
</div>
<h4 id="only"><a class="anchorlink" href="#only">9.2 <code>only</code></a></h4><p>También puede anular condiciones utilizando el método <code>only</code>. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Article.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC

# Original query without `only`
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC LIMIT 20

</code></pre>
</div>
<h4 id="reselect"><a class="anchorlink" href="#reselect">9.3 <code>reselect</code></a></h4><p>El método <code>reselect</code> anula una instrucción select existente. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Post.select(:title, :body).reselect(:created_at)
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT `posts`.`created_at` FROM `posts`
</code></pre>
</div>
<p>En caso de que no se use la cláusula <code>reselect</code>,</p><div class="code_container">
<pre><code class="language-ruby">Post.select(:title, :body).select(:created_at)
</code></pre>
</div>
<p>el SQL ejecutado sería:</p><div class="code_container">
<pre><code class="language-sql">SELECT `posts`.`title`, `posts`.`body`, `posts`.`created_at` FROM `posts`
</code></pre>
</div>
<h4 id="reorder"><a class="anchorlink" href="#reorder">9.4 <code>reorder</code></a></h4><p>El método <code>reorder</code> anula el orden de alcance predeterminado. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  has_many :comments, -&gt; { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
</code></pre>
</div>
<p>En el caso donde no se usa la cláusula <code>reorder</code>, el SQL ejecutado sería:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
</code></pre>
</div>
<h4 id="reverse-order"><a class="anchorlink" href="#reverse-order">9.5 <code>reverse_order</code></a></h4><p>El método <code>reverse_order</code> revierte la cláusula de ordenación si se especifica.</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count &gt; 10").order(:name).reverse_order
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY name DESC
</code></pre>
</div>
<p>Si no se especifica una cláusula de pedido en la consulta, el <code>reverse_order</code> ordena por la clave primaria en orden inverso.</p><div class="code_container">
<pre><code class="language-ruby">Client.where("orders_count &gt; 10").reverse_order
</code></pre>
</div>
<p>El SQL que se ejecutaría:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY clients.id DESC
</code></pre>
</div>
<p>Este método ** no ** acepta argumentos. </p><h4 id="rewhere"><a class="anchorlink" href="#rewhere">9.6 <code>rewhere</code></a></h4><p>El método <code>rewhere</code> anula una condición existente, llamada where. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Article.where(trashed: true).rewhere(trashed: false)
</code></pre>
</div>
<p>El SQL que se ejecutar</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
</code></pre>
</div>
<h3 id="null-relation"><a class="anchorlink" href="#null-relation">10 Null Relation</a></h3><p>El método <code>none</code> devuelve una relación encadenable sin registros. Cualquier condición posterior encadenada a la relación devuelta continuará generando relaciones vacías. Esto es útil en escenarios donde se necesita una respuesta encadenable a un método o un alcance que podría devolver ningun resultados.</p><div class="code_container">
<pre><code class="language-ruby">Article.none # returns an empty Relation and fires no queries.
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby"># The visible_articles method below is expected to return a Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # =&gt; returning [] or nil breaks the caller code in this case
  end
end
</code></pre>
</div>
<h3 id="readonly-objects"><a class="anchorlink" href="#readonly-objects">11 Readonly Objects</a></h3><p>Active Record proporciona el método <code>readonly</code> en una relación para rechazar explícitamente la modificación de cualquiera de los objetos devueltos. Cualquier intento de alterar un registro de solo lectura no tendrá éxito, generando una excepción <code>ActiveRecord::ReadOnlyRecord</code>.</p><div class="code_container">
<pre><code class="language-ruby">client = Client.readonly.first
client.visits += 1
client.save
</code></pre>
</div>
<p>Como <code>client</code> está configurado explícitamente para ser un objeto de solo lectura, el código anterior generará una excepción <code>ActiveRecord::ReadOnlyRecord</code> cuando llame a <code>client.save</code> con un valor actualizado de <em>visits</em>.</p><h3 id="locking-records-for-update"><a class="anchorlink" href="#locking-records-for-update">12 Locking Records for Update</a></h3><p>El bloqueo es útil para prevenir las condiciones de carrera al actualizar registros en la base de datos y garantizar actualizaciones atómicas.</p><p>Active Record proporciona dos mecanismos de bloqueo:</p>
<ul>
<li>Bloqueo Optimistic (optimista)</li>
<li>Bloqueo Pessimistic (pesimista)</li>
</ul>
<h4 id="optimistic-locking"><a class="anchorlink" href="#optimistic-locking">12.1 Optimistic Locking</a></h4><p>El bloqueo optimista permite que varios usuarios accedan al mismo registro para las ediciones, y supone un mínimo de conflictos con los datos. Lo hace comprobando si otro proceso ha realizado cambios en un registro desde que se abrió. Se produce una excepción <code>ActiveRecord::StaleObjectError</code> si eso ha ocurrido y se ignora la actualización.</p><p><strong>Optimistic locking column</strong></p><p>Para utilizar el bloqueo optimista, la tabla debe tener una columna llamada <code>lock_version</code> de tipo entero. Cada vez que se actualiza el registro, Active Record incrementa la columna <code>lock_version</code>. Si se realiza una solicitud de actualización con un valor inferior en el campo <code>lock_version</code> que el que está actualmente en la columna<code>lock_version</code> en la base de datos, la solicitud de actualización fallará con un <code>ActiveRecord::StaleObjectError</code>. Ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # Raises an ActiveRecord::StaleObjectError
</code></pre>
</div>
<p>Entonces es su responsabilidad de lidiar con el conflicto rescatando la excepción y revertiendo, fusionando o aplicando la lógica comercial necesaria para resolver el conflicto.</p><p>Este comportamiento se puede desactivar estableciendo <code>ActiveRecord::Base.lock_optimistically = false</code>.</p><p>Para anular el nombre de la columna <code>lock_version</code>,<code>ActiveRecord::Base</code> proporciona un atributo de clase llamado <code>Lock_column</code>:</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  self.locking_column = :lock_client_column
end
</code></pre>
</div>
<h4 id="pessimistic-lockin"><a class="anchorlink" href="#pessimistic-lockin">12.2 Pessimistic Lockin</a></h4><p>El bloqueo pesimista utiliza un mecanismo de bloqueo proporcionado por la base de datos subyacente. El uso de <code>lock</code> cuando se construye una relación obtiene un bloqueo exclusivo en las filas seleccionadas. Las relaciones que usan <code>lock</code> generalmente se envuelven dentro de una transacción para evitar condiciones de punto muerto.</p><p>Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
</code></pre>
</div>
<p>La sesión anterior produce el siguiente SQL para un servidor MySQL:</p><div class="code_container">
<pre><code class="language-sql">SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
</code></pre>
</div>
<p>También puede pasar SQL sin formato al método <code>lock</code> para permitir diferentes tipos de bloqueos. Por ejemplo, MySQL tiene una expresión llamada <code>LOCK IN SHARE MODE</code> donde puede bloquear un registro pero aún permitir que otras consultas lo lean. Para especificar esta expresión, simplemente pásala como la opción de bloqueo:</p><div class="code_container">
<pre><code class="language-ruby">Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
</code></pre>
</div>
<p>Si ya tiene una instancia de su modelo, puede iniciar una transacción y adquirir el bloqueo de una vez usando el siguiente código:</p><div class="code_container">
<pre><code class="language-ruby">item = Item.first
item.with_lock do
  # This block is called within a transaction,
  # item is already locked.
  item.increment!(:views)
end
</code></pre>
</div>
<h3 id="joining-tables"><a class="anchorlink" href="#joining-tables">13 Joining Tables</a></h3><p>Active Record proporciona dos métodos de búsqueda para especificar cláusulas <code>JOIN</code> en
SQL resultante: <code>joins</code> y<code>left_outer_joins</code>.
En donde <code>joins</code> se debe usarse para <code>INNER JOIN</code> o consultas personalizadas,
<code>left_outer_joins</code> se usa para consultas que usan<code>LEFT OUTER JOIN</code>.</p><h4 id="une"><a class="anchorlink" href="#une">13.1 <code>une</code></a></h4><p>Hay varias formas de usar el método <code>join</code>.</p><h5 id="using-a-string-sql-fragment"><a class="anchorlink" href="#using-a-string-sql-fragment">13.1.1 Using a String SQL Fragment</a></h5><p>Simplemente puede proporcionar el SQL sin formato que especifica la cláusula <code>JOIN</code> a<code>join</code>:</p><div class="code_container">
<pre><code class="language-ruby">Author.joins("INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'")
</code></pre>
</div>
<p>Esto dará como resultado el siguiente SQL:</p><div class="code_container">
<pre><code class="language-sql">SELECT authors.* FROM authors INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'
</code></pre>
</div>
<h5 id="using-array-hash-of-named-associations"><a class="anchorlink" href="#using-array-hash-of-named-associations">13.1.2 Using Array/Hash of Named Associations</a></h5><p>Active Record le permite usar los nombres de las <a href="association_basics.html">associations</a> definidas en el modelo como un acceso directo para especificar cláusulas <code>JOIN</code> para esas asociaciones cuando se utiliza el método <code>join</code>.</p><p>Por ejemplo, considere los siguientes modelos de <code>Category</code>,<code>Article</code>, <code>Comment</code>,<code>Guest</code> y <code>Tag</code>:</p><div class="code_container">
<pre><code class="language-ruby">class Category &lt; ApplicationRecord
  has_many :articles
end

class Article &lt; ApplicationRecord
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment &lt; ApplicationRecord
  belongs_to :article
  has_one :guest
end

class Guest &lt; ApplicationRecord
  belongs_to :comment
end

class Tag &lt; ApplicationRecord
  belongs_to :article
end
</code></pre>
</div>
<p>Ahora, todo lo siguiente producirá las consultas de unión esperadas usando <code>INNER JOIN</code>:</p><h6 id="joining-a-single-association"><a class="anchorlink" href="#joining-a-single-association">13.1.2.1 Joining a Single Association</a></h6><div class="code_container">
<pre><code class="language-ruby">Category.joins(:articles)
</code></pre>
</div>
<p>Esto produce:</p><div class="code_container">
<pre><code class="language-sql">SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
</code></pre>
</div>
<p>O, en español: "devolver un objeto ategoría para todas las categorías con artículos". Tenga en cuenta que verá categorías duplicadas si más de un artículo tiene la misma categoría. Si desea categorías únicas, puede usar <code>Category.joins(:articles).distinct</code>.</p><h5 id="joining-multiple-associations"><a class="anchorlink" href="#joining-multiple-associations">13.1.3 Joining Multiple Associations</a></h5><div class="code_container">
<pre><code class="language-ruby">Article.joins(:category, :comments)
</code></pre>
</div>
<p>Esto produce:</p><div class="code_container">
<pre><code class="language-sql">SELECT articles.* FROM articles
  INNER JOIN categories ON categories.id = articles.category_id
  INNER JOIN comments ON comments.article_id = articles.id
</code></pre>
</div>
<p>O, en español: "devolver todos los artículos que tengan una categoría y al menos un comentario". Tenga en cuenta nuevamente que los artículos con múltiples comentarios aparecerán varias veces.</p><h6 id="joining-nested-associations-single-level"><a class="anchorlink" href="#joining-nested-associations-single-level">13.1.3.1 Joining Nested Associations (Single Level)</a></h6><div class="code_container">
<pre><code class="language-ruby">Article.joins(comments: :guest)
</code></pre>
</div>
<p>Esto produce:</p><div class="code_container">
<pre><code class="language-sql">SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
</code></pre>
</div>
<p>O, en español: "devolver todos los artículos que tengan un comentario hecho por un invitado".</p><h6 id="joining-nested-associations-multiple-level"><a class="anchorlink" href="#joining-nested-associations-multiple-level">13.1.3.2 Joining Nested Associations (Multiple Level)</a></h6><div class="code_container">
<pre><code class="language-ruby">Category.joins(articles: [{ comments: :guest }, :tags])
</code></pre>
</div>
<p>Esto produce:</p><div class="code_container">
<pre><code class="language-sql">SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.article_id = articles.id
</code></pre>
</div>
<p>O, en español: "devuelve todas las categorías que tienen artículos, donde esos artículos tienen un comentario hecho por un invitado y donde esos artículos también tienen una etiqueta".</p><h5 id="specifying-conditions-on-the-joined-tables"><a class="anchorlink" href="#specifying-conditions-on-the-joined-tables">13.1.4 Specifying Conditions on the Joined Tables</a></h5><p>Puede especificar condiciones en las tablas unidas utilizando las condiciones normales <a href="#array-condition">Array</a> y <a href="#pure-string-condition">String</a>. <a href="#hash-conditions">Hash conditions</a> proporcionan una sintaxis especial para especificar condiciones para las tablas unidas:</p><div class="code_container">
<pre><code class="language-ruby">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' =&gt; time_range)
</code></pre>
</div>
<p>Una sintaxis alternativa y más limpia es anidar las condiciones hash:</p><div class="code_container">
<pre><code class="language-ruby">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })
</code></pre>
</div>
<p>Esto encontrará a todos los clientes que tienen pedidos que se crearon ayer, nuevamente utilizando una expresión SQL <code>BETWEEN</code>.</p><h4 id="left-outer-joins"><a class="anchorlink" href="#left-outer-joins">13.2 <code>left_outer_joins</code></a></h4><p>Si desea seleccionar un conjunto de registros, estén o no asociados
registros que puede usar el método <code>left_outer_joins</code>.</p><div class="code_container">
<pre><code class="language-ruby">Author.left_outer_joins(:posts).distinct.select('authors.*, COUNT(posts.*) AS posts_count').group('authors.id')
</code></pre>
</div>
<p>Que produce:</p><div class="code_container">
<pre><code class="language-sql">SELECT DISTINCT authors.*, COUNT(posts.*) AS posts_count FROM "authors"
LEFT OUTER JOIN posts ON posts.author_id = authors.id GROUP BY authors.id
</code></pre>
</div>
<p>Lo que significa: "devolver a todos los autores con su recuento de publicaciones, ya sea que
tiene alguna publicación"</p><h3 id="eager-loading-associations"><a class="anchorlink" href="#eager-loading-associations">14 Eager Loading Associations</a></h3><p>La carga ansiosa es el mecanismo para cargar los registros asociados de los objetos devueltos por <code>Model.find</code> utilizando la menor cantidad de consultas posible.</p><p><strong>Problema de consultas N + 1</strong></p><p>Considere el siguiente código, que encuentra 10 clientes e imprime sus códigos postales:</p><div class="code_container">
<pre><code class="language-ruby">clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
</code></pre>
</div>
<p>Este código se ve bien a primera vista. Pero el problema radica en el número total de consultas ejecutadas. El código anterior ejecuta 1 (para encontrar 10 clientes) + 10 (uno por cada cliente para cargar la dirección) = <strong>11</strong> consultas en total.</p><p><strong>Solución al problema de consultas N + 1</strong></p><p>Active Record le permite especificar de antemano todas las asociaciones que se van a cargar. Esto es posible especificando el método <code>includes</code> de la llamada <code>Model.find</code>. Con <code>includes</code>, Active Record garantiza que todas las asociaciones especificadas se carguen utilizando el mínimo número posible de consultas.</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
</code></pre>
</div>
<h4 id="eager-loading-multiple-associations"><a class="anchorlink" href="#eager-loading-multiple-associations">14.1 Eager Loading Multiple Associations</a></h4><p>Active Record le permite cargar cualquier número de asociaciones con una sola llamada <code>Model.find</code> mediante el uso de una matriz, hash o un hash anidado de matriz / hash con el método <code>include</code>.</p><h5 id="array-of-multiple-associations"><a class="anchorlink" href="#array-of-multiple-associations">14.1.1 Array of Multiple Associations</a></h5><div class="code_container">
<pre><code class="language-ruby">Article.includes(:category, :comments)
</code></pre>
</div>
<p>Esto carga todos los artículos y la categoría asociada y comentarios para cada artículo.</p><h5 id="nested-associations-hash"><a class="anchorlink" href="#nested-associations-hash">14.1.2 Nested Associations Hash</a></h5><div class="code_container">
<pre><code class="language-ruby">Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
</code></pre>
</div>
<p>Esto encontrará la categoría con ID 1 y cargará ansiosamente todos los artículos asociados, las etiquetas y comentarios de los artículos asociados y la asociación de invitados de cada comentario.</p><h4 id="specifying-conditions-on-eager-loaded-associations"><a class="anchorlink" href="#specifying-conditions-on-eager-loaded-associations">14.2 Specifying Conditions on Eager Loaded Associations</a></h4><p>A pesar de que Active Record le permite especificar condiciones en las asociaciones cargadas ansiosas al igual que <code>joins</code>, la forma recomendada es utilizar <a href="#joining-tables">joins</a> en su lugar.</p><p>Sin embargo, si debe hacer esto, puede usar <code>where</code> como lo haría normalmente.</p><div class="code_container">
<pre><code class="language-ruby">Article.includes(:comments).where(comments: { visible: true })
</code></pre>
</div>
<p>Esto generaría una consulta que contiene un <code>LEFT OUTER JOIN</code> mientras que el
El método <code>joins</code> generaría uno usando la función <code>INNER JOIN</code> en su lugar.</p><div class="code_container">
<pre><code class="language-ruby">  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
</code></pre>
</div>
<p>Si no existiera la condición <code>where</code>, esto generaría el conjunto normal de dos consultas.</p><p>NOTA: Usar <code>where</code> de esta manera solo funcionará cuando le pase un Hash. por
Fragmentos de SQL end donde se necesita usar <code>referencias</code> para forzar tablas unidas:</p><div class="code_container">
<pre><code class="language-ruby">Article.includes(:comments).where("comments.visible = true").references(:comments)
</code></pre>
</div>
<p>Si, en el caso de esta consulta <code>includes</code>, no hubo comentarios para
artículos, todos los artículos aún se cargarían. Mediante el uso de <code>joins</code> (un INNER
JOIN), las condiciones de unión <strong>deben</strong> coincidir, de lo contrario no se registrarán registros
devuelto.</p><p>NOTA: Si una asociación está ansiosamente cargada como parte de una unión, los campos de una cláusula de selección personalizada no estarán presentes en los modelos cargados.
Esto se debe a que es ambiguo si deberían aparecer en el registro primario o en el secundario.</p><h3 id="scopes"><a class="anchorlink" href="#scopes">15 Scopes</a></h3><p>El alcance le permite especificar consultas de uso común a las que se puede hacer referencia como llamadas a métodos en los objetos o modelos de asociación. Con estos ámbitos, puede utilizar todos los métodos cubiertos anteriormente, como <code>where</code>,<code>join</code> e <code>include</code>. Todos los cuerpos de ámbito deben devolver un <code>ActiveRecord::Relation</code> o <code>nil</code> para permitir que se invoquen otros métodos (como otros ámbitos).</p><p>Para definir un alcance simple, usamos el método <code>scope</code> dentro de la clase, pasando la consulta que nos gustaría ejecutar cuando se llama a este alcance:</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  scope :published, -&gt; { where(published: true) }
end
</code></pre>
</div>
<p>Los ámbitos también se pueden encadenar dentro de los ámbitos:</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  scope :published,               -&gt; { where(published: true) }
  scope :published_and_commented, -&gt; { published.where("comments_count &gt; 0") }
end
</code></pre>
</div>
<p>Para llamar a este alcance <code>published</code> podemos llamarlo en la clase:</p><div class="code_container">
<pre><code class="language-ruby">Article.published # =&gt; [published articles]
</code></pre>
</div>
<p>O en una asociación que consta de objetos <code>Article</code>:</p><div class="code_container">
<pre><code class="language-ruby">category = Category.first
category.articles.published # =&gt; [published articles belonging to this category]
</code></pre>
</div>
<h4 id="passing-in-arguments"><a class="anchorlink" href="#passing-in-arguments">15.1 Passing in arguments</a></h4><p>Su alcance puede tomar argumentos:</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) }
end
</code></pre>
</div>
<p>Llame al ámbito como si fuera un método de clase:</p><div class="code_container">
<pre><code class="language-ruby">Article.created_before(Time.zone.now)
</code></pre>
</div>
<p>Sin embargo, esto es solo duplicar la funcionalidad que le proporcionaría un método de clase.</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  def self.created_before(time)
    where("created_at &lt; ?", time)
  end
end
</code></pre>
</div>
<p>Estos métodos seguirán siendo accesibles en los objetos de asociación:</p><div class="code_container">
<pre><code class="language-ruby">category.articles.created_before(time)
</code></pre>
</div>
<h4 id="using-conditionals"><a class="anchorlink" href="#using-conditionals">15.2 Using conditionals</a></h4><p>Su alcance puede utilizar condicionales:</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) if time.present? }
end
</code></pre>
</div>
<p>Al igual que los otros ejemplos, esto se comportará de manera similar a un método de clase.</p><div class="code_container">
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  def self.created_before(time)
    where("created_at &lt; ?", time) if time.present?
  end
end
</code></pre>
</div>
<p>Sin embargo, hay una advertencia importante: un ámbito siempre devolverá un objeto <code>ActiveRecord::Relation</code>, incluso si el condicional se evalúa como <code>false</code>, mientras que un método de clase devolverá <code>nil</code>. Esto puede causar <code>NoMethodError</code> al encadenar métodos de clase con condicionales, si alguno de los condicionales devuelve <code>falso</code>.</p><h4 id="applying-a-default-scope"><a class="anchorlink" href="#applying-a-default-scope">15.3 Applying a default scope</a></h4><p>Si deseamos que se aplique un alcance en todas las consultas al modelo, podemos usar el
Método <code>default_scope</code> dentro del modelo mismo.</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  default_scope { where("removed_at IS NULL") }
end
</code></pre>
</div>
<p>Cuando las consultas se ejecutan en este modelo, la consulta SQL ahora se verá similar a
esta:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE removed_at IS NULL
</code></pre>
</div>
<p>Si necesita hacer cosas más complejas con un alcance predeterminado, también puede
definirlo como un método de clase:</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  def self.default_scope
    # Should return an ActiveRecord::Relation.
  end
end
</code></pre>
</div>
<p>NOTA: El <code>default_scope</code> también se aplica al crear / construir un registro
cuando los argumentos de alcance se dan como un <code>Hash</code>. No se aplica mientras
actualizar un registro P.ej.:</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  default_scope { where(active: true) }
end

Client.new          # =&gt; #&lt;Client id: nil, active: true&gt;
Client.
</code></pre>
</div>
<p>Tenga en cuenta que, cuando se proporciona en el formato <code>Array</code>, los argumentos de consulta<code>default_scope</code>
no se puede convertir a un <code>Hash</code> para la asignación de atributos predeterminada. P.ej.:</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  default_scope { where("active = ?", true) }
end

Client.new # =&gt; #&lt;Client id: nil, active: nil&gt;
</code></pre>
</div>
<h4 id="merging-of-scopes"><a class="anchorlink" href="#merging-of-scopes">15.4 Merging of scopes</a></h4><p>Al igual que los alcances de las cláusulas <code>where</code> se fusionan utilizando condiciones <code>AND</code>.</p><div class="code_container">
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
</code></pre>
</div>
<p>Podemos mezclar y combinar las condiciones de <code>scope</code> y <code>here</code> y el SQL final
tendrá todas las condiciones unidas con <code>AND</code>.</p><div class="code_container">
<pre><code class="language-ruby">User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
</code></pre>
</div>
<p>Si queremos que gane la última cláusula <code>where</code>, entonces <code>Relation#merge</code> puede
ser usado.</p><div class="code_container">
<pre><code class="language-ruby">User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
</code></pre>
</div>
<p>Una advertencia importante es que <code>default_scope</code> se antepondrá en
condiciones de <code>scope</code> y <code>where</code>.</p><div class="code_container">
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  default_scope { where state: 'pending' }
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'
</code></pre>
</div>
<p>Como puede ver arriba, el <code>default_scope</code> se está fusionando en ambos
condiciones de <code>scope</code> y <code>where</code>.</p><h4 id="removing-all-scoping"><a class="anchorlink" href="#removing-all-scoping">15.5 Removing All Scoping</a></h4><p>Si deseamos eliminar el alcance por cualquier motivo, podemos utilizar el método <code>unscoped</code>. Esto es
especialmente útil si se especifica un <code>default_scope</code> en el modelo y no debe ser
solicitó esta consulta en particular.</p><div class="code_container">
<pre><code class="language-ruby">Client.unscoped.load
</code></pre>
</div>
<p>Este método elimina todo el alcance y hará una consulta normal en la tabla.</p><div class="code_container">
<pre><code class="language-ruby">Client.unscoped.all
# SELECT "clients".* FROM "clients"

Client.where(published: false).unscoped.all
# SELECT "clients".* FROM "clients"
</code></pre>
</div>
<p><code>unscoped</code> can also accept a block.</p><div class="code_container">
<pre><code class="language-ruby">Client.unscoped {
  Client.created_before(Time.zone.now)
}
</code></pre>
</div>
<h3 id="dynamic-finders"><a class="anchorlink" href="#dynamic-finders">16 Dynamic Finders</a></h3><p>Para cada campo (también conocido como atributo) que defina en su tabla, Active Record proporciona un método de búsqueda. Si tiene un campo llamado <code>first_name</code> en su modelo <code>Client</code>, por ejemplo, obtiene <code>find_by_first_name</code> gratis de Active Record. Si tiene un campo <code>locked</code> en el modelo<code>Client</code>, también obtiene el método <code>find_by_locked</code>.</p><p>Puede especificar un signo de exclamación (<code>!</code>) Al final de los buscadores dinámicos para que generen un error <code>ActiveRecord::RecordNotFound</code> si no devuelven ningún registro, como <code>Client.find_by_name!("Ryan")</code></p><p>Si desea encontrar tanto por nombre como bloqueado, puede encadenar estos buscadores simplemente escribiendo "<code>and</code>" entre los campos. Por ejemplo, <code>Client.find_by_first_name_and_locked("Ryan", true)</code>.</p><h3 id="enums"><a class="anchorlink" href="#enums">17 Enums</a></h3><p>La macro <code>enum</code> asigna una columna entera a un conjunto de valores posibles.</p><div class="code_container">
<pre><code class="language-ruby">class Book &lt; ApplicationRecord
  enum availability: [:available, :unavailable]
end
</code></pre>
</div>
<p>Esto creará automáticamente los <a href="#scopes">scopes</a> correspondientes para consultar el
modelo. Los métodos para la transición entre estados y consultar el estado actual también son
adicional.</p><div class="code_container">
<pre><code class="language-ruby"># Both examples below query just available books.
Book.available
# or
Book.where(availability: :available)

book = Book.new(availability: :available)
book.available?   # =&gt; true
book.unavailable! # =&gt; true
book.available?   # =&gt; false
</code></pre>
</div>
<p>Lea la documentación completa sobre las enumeraciones.
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html">in the Rails API docs</a>.</p><h3 id="understanding-the-method-chaining"><a class="anchorlink" href="#understanding-the-method-chaining">18 Understanding The Method Chaining</a></h3><p>El patrón de registro activo implementa <a href="https://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>,
lo que nos permite usar múltiples métodos Active Record juntos de una manera simple y directa.</p><p>Puede encadenar métodos en una instrucción cuando el método anterior llamado devuelve un
<code>ActiveRecord::Relation</code>, como<code>all</code>, <code>where</code> y <code>joins</code>. Métodos que regresan
un solo objeto (ver <a href="#retrieving-a-single-object">Retrieving a Single Object Section</a>)
tiene que estar al final de la declaración.</p><p>Hay algunos ejemplos a continuación. Esta guía no cubrirá todas las posibilidades, solo algunas como ejemplos.
Cuando se llama a un método de Registro activo, la consulta no se genera de inmediato y no se envía a la base de datos,
esto solo sucede cuando los datos son realmente necesarios. Entonces, cada ejemplo a continuación genera una sola consulta.</p><h4 id="retrieving-filtered-data-from-multiple-tables"><a class="anchorlink" href="#retrieving-filtered-data-from-multiple-tables">18.1 Retrieving filtered data from multiple tables</a></h4><div class="code_container">
<pre><code class="language-ruby">Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at &gt; ?', 1.week.ago)
</code></pre>
</div>
<p>El resultado debería ser algo como esto:</p><div class="code_container">
<pre><code class="language-sql">SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at &gt; '2015-01-01'
</code></pre>
</div>
<h4 id="retrieving-specific-data-from-multiple-tables"><a class="anchorlink" href="#retrieving-specific-data-from-multiple-tables">18.2 Retrieving specific data from multiple tables</a></h4><div class="code_container">
<pre><code class="language-ruby">Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' =&gt; 'John') # this should be the last
</code></pre>
</div>
<p>Lo anterior debería generar:</p><div class="code_container">
<pre><code class="language-sql">SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1
</code></pre>
</div>
<p>NOTA: Tenga en cuenta que si una consulta coincide con varios registros, <code>find_by</code>
busque solo el primero e ignore a los demás (consulte la declaración anterior 
<code>LIMIT 1</code>).</p><h3 id="find-or-build-a-new-object"><a class="anchorlink" href="#find-or-build-a-new-object">19 Find or Build a New Object</a></h3><p>Es común que necesite encontrar un registro o crearlo si no existe. Puede hacerlo con los métodos <code>find_or_create_by</code> y <code>find_or_create_by!</code>.</p><h4 id="find-or-create-by"><a class="anchorlink" href="#find-or-create-by">19.1 <code>find_or_create_by</code></a></h4><p>El método <code>find_or_create_by</code> verifica si existe un registro con los atributos especificados. Si no es así, se llama a <code>create</code>. Veamos un ejemplo.</p><p>Supongamos que desea encontrar un cliente llamado 'Andy', y si no hay ninguno, cree uno. Puede hacerlo ejecutando:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_or_create_by(first_name: 'Andy')
# =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;
</code></pre>
</div>
<p>El SQL generado por este método se ve así:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
</code></pre>
</div>
<p><code>find_or_create_by</code> devuelve el registro que ya existe o el nuevo registro. En nuestro caso, todavía no teníamos un cliente llamado Andy, por lo que el registro se crea y se devuelve.</p><p>El nuevo registro podría no guardarse en la base de datos; eso depende de si las validaciones pasaron o no (al igual que <code>create</code>).</p><p>Supongamos que queremos establecer el atributo <code>locked</code> en <code>false</code> si estamos
creando un nuevo registro, pero no queremos incluirlo en la consulta. Entonces
queremos encontrar al cliente llamado "Andy", o si ese cliente no
existe, crea un cliente llamado "Andy" que no está bloqueado.</p><p>Podemos lograr esto de dos maneras. El primero es usar <code>create_with</code>:</p><div class="code_container">
<pre><code class="language-ruby">Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
</code></pre>
</div>
<p>La segunda forma es usar un bloque:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
</code></pre>
</div>
<p>El bloque solo se ejecutará si se está creando el cliente.
La segunda vez que ejecutamos este código, el bloque será ignorado.</p><h4 id="find-or-create-by-bang"><a class="anchorlink" href="#find-or-create-by-bang">19.2 <code>find_or_create_by!</code></a></h4><p>También puede usar <code>find_or_create_by!</code> para generar una excepción si el nuevo registro no es válido. Las validaciones no están cubiertas en esta guía, pero supongamos por un momento que agregue temporalmente</p><div class="code_container">
<pre><code class="language-ruby">validates :orders_count, presence: true
</code></pre>
</div>
<p>a su modelo de <code>Client</code>. Si intenta crear un nuevo <code>Client</code> sin pasar un<code>orders_count</code>, el registro no será válido y se generará una excepción:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_or_create_by!(first_name: 'Andy')
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
</code></pre>
</div>
<h4 id="find-or-initialize-by"><a class="anchorlink" href="#find-or-initialize-by">19.3 <code>find_or_initialize_by</code></a></h4><p>El método <code>find_or_initialize_by</code> funcionará igual que
<code>find_or_create_by</code> pero llamará a <code>new</code> en lugar de <code>create</code>. Esta
significa que se creará una nueva instancia de modelo en la memoria pero no se
guardado en la base de datos. Continuando con el ejemplo <code>find_or_create_by</code>, nosotros
ahora quiero que el cliente se llame 'Nick':</p><div class="code_container">
<pre><code class="language-ruby">nick = Client.find_or_initialize_by(first_name: 'Nick')
# =&gt; #&lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

nick.persisted?
# =&gt; false

nick.new_record?
# =&gt; true
</code></pre>
</div>
<p>Debido a que el objeto aún no está almacenado en la base de datos, el SQL generado se ve así:</p><div class="code_container">
<pre><code class="language-sql">SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
</code></pre>
</div>
<p>Cuando desee guardarlo en la base de datos, simplemente llame a <code>save</code>:</p><div class="code_container">
<pre><code class="language-ruby">nick.save
# =&gt; true
</code></pre>
</div>
<h3 id="finding-by-sql"><a class="anchorlink" href="#finding-by-sql">20 Finding by SQL</a></h3><p>Si desea usar su propio SQL para buscar registros en una tabla, puede usar <code>find_by_sql</code>. El método <code>find_by_sql</code> devolverá una matriz de objetos incluso si la consulta subyacente devuelve un solo registro. Por ejemplo, podría ejecutar esta consulta:</p><div class="code_container">
<pre><code class="language-ruby">Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# =&gt;  [
#   #&lt;Client id: 1, first_name: "Lucas" &gt;,
#   #&lt;Client id: 2, first_name: "Jan" &gt;,
#   ...
# ]
</code></pre>
</div>
<p><code>find_by_sql</code> le proporciona una forma sencilla de realizar llamadas personalizadas a la base de datos y recuperar objetos instanciados.</p><h4 id="select-all"><a class="anchorlink" href="#select-all">20.1 <code>select_all</code></a></h4><p><code>find_by_sql</code> tiene un pariente cercano llamado <code>connection#select_all</code>. <code>select_all</code> recuperará
objetos de la base de datos usando SQL personalizado como <code>find_by_sql</code> pero no los instanciará.
Este método devolverá una instancia de la clase <code>ActiveRecord::Result</code> y llamará a <code>to_a</code> en este
objeto le devolvería una matriz de hashes donde cada hash indica un registro.</p><div class="code_container">
<pre><code class="language-ruby">Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'").to_a
# =&gt; [
#   {"first_name"=&gt;"Rafael", "created_at"=&gt;"2012-11-10 23:23:45.281189"},
#   {"first_name"=&gt;"Eileen", "created_at"=&gt;"2013-12-09 11:22:35.221282"}
# ]
</code></pre>
</div>
<h4 id="pluck"><a class="anchorlink" href="#pluck">20.2 <code>pluck</code></a></h4><p><code>pluck</code> puede usarse para consultar columnas simples o múltiples desde la tabla subyacente de un modelo. Acepta una lista de nombres de columnas como argumento y devuelve una matriz de valores de las columnas especificadas con el tipo de datos correspondiente.</p><div class="code_container">
<pre><code class="language-ruby">Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# =&gt; [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# =&gt; ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
</code></pre>
</div>
<p><code>pluck</code> hace posible reemplazar código como:</p><div class="code_container">
<pre><code class="language-ruby">Client.select(:id).map { |c| c.id }
# or
Client.select(:id).map(&amp;:id)
# or
Client.select(:id, :name).map { |c| [c.id, c.name] }
</code></pre>
</div>
<p>con:</p><div class="code_container">
<pre><code class="language-ruby">Client.pluck(:id)
# or
Client.pluck(:id, :name)
</code></pre>
</div>
<p>La diferencia de <code>select</code>,<code>pluck</code> convierte directamente el resultado de una base de datos en un Ruby <code>Array</code>,
sin construir objetos <code>ActiveRecord</code>. Esto puede significar un mejor rendimiento para
una consulta grande o de ejecución frecuente. Sin embargo, cualquier anulación de método modelo
No estar disponible. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby">class Client &lt; ApplicationRecord
  def name
    "I am #{super}"
  end
end

Client.select(:name).map &amp;:name
# =&gt; ["I am David", "I am Jeremy", "I am Jose"]

Client.pluck(:name)
# =&gt; ["David", "Jeremy", "Jose"]
</code></pre>
</div>
<p>No está limitado a consultar campos desde una sola tabla, también puede consultar varias tablas.</p><div class="code_container">
<pre><code class="language-ruby">Client.joins(:comments, :categories).pluck("clients.email, comments.title, categories.name")
</code></pre>
</div>
<p>Además, a diferencia de <code>select</code> y otros ámbitos de<code>Relation</code>, <code>pluck</code> desencadena un inmediato
consulta y, por lo tanto, no se puede encadenar con otros ámbitos, aunque puede funcionar con
ámbitos ya construidos anteriormente:</p><div class="code_container">
<pre><code class="language-ruby">Client.pluck(:name).limit(1)
# =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;

Client.limit(1).pluck(:name)
# =&gt; ["David"]
</code></pre>
</div>
<p>NOTA: También debe saber que el uso de <code>pluck</code> activará la carga ansiosa si el objeto de relación contiene valores de inclusión, incluso si la carga ansiosa no es necesaria para la consulta. Por ejemplo:</p><div class="code_container">
<pre><code class="language-ruby"># store association for reusing it
assoc = Company.includes(:account)
assoc.pluck(:id)
# SELECT "companies"."id" FROM "companies" LEFT OUTER JOIN "accounts" ON "accounts"."id" = "companies"."account_id"
</code></pre>
</div>
<p>Una forma de evitar esto es <code>unscope</code> la inclusión</p><div class="code_container">
<pre><code class="language-ruby">assoc.unscope(:includes).pluck(:id)
</code></pre>
</div>
<h4 id="ids"><a class="anchorlink" href="#ids">20.3 <code>ids</code></a></h4><p>Los <code>ids</code> se pueden usar para seleccionar todas las ID de la relación utilizando la clave primaria de la tabla.</p><div class="code_container">
<pre><code class="language-ruby">Person.ids
# SELECT id FROM people
</code></pre>
</div>
<div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people
</code></pre>
</div>
<h3 id="existence-of-objects"><a class="anchorlink" href="#existence-of-objects">21 Existence of Objects</a></h3><p>Si simplemente desea verificar la existencia del objeto, hay un método llamado <code>exists?</code>.
Este método consultará la base de datos utilizando la misma consulta que <code>find</code>, pero en lugar de devolver un
objeto o colección de objetos devolverá <code>true</code> o <code>false</code>.</p><div class="code_container">
<pre><code class="language-ruby">Client.exists?(1)
</code></pre>
</div>
<p>El método <code>exists?</code>también toma múltiples valores, pero el problema es que devolverá <code>true</code> si alguno
uno de esos registros existe.</p><div class="code_container">
<pre><code class="language-ruby">Client.exists?(id: [1,2,3])
# or
Client.exists?(name: ['John', 'Sergei'])
</code></pre>
</div>
<p>Incluso es posible usar <code>exists?</code> sin ningún argumento sobre un modelo o una relación.</p><div class="code_container">
<pre><code class="language-ruby">Client.where(first_name: 'Ryan').exists?
</code></pre>
</div>
<p>The above returns <code>true</code> if there is at least one client with the <code>first_name</code> 'Ryan' and <code>false</code>
otherwise.</p><div class="code_container">
<pre><code class="language-ruby">Client.exists?
</code></pre>
</div>
<p>Lo anterior devuelve <code>false</code> si la tabla <code>clients</code> está vacía y <code>true</code> de lo contrario.</p><p>También puede usar <code>any?</code> Y <code>many?</code> Para verificar la existencia en un modelo o relación.</p><div class="code_container">
<pre><code class="language-ruby"># via a model
Article.any?
Article.many?

# via a named scope
Article.recent.any?
Article.recent.many?

# via a relation
Article.where(published: true).any?
Article.where(published: true).many?

# via an association
Article.first.categories.any?
Article.first.categories.many?
</code></pre>
</div>
<h3 id="calculations"><a class="anchorlink" href="#calculations">22 Calculations</a></h3><p>Esta sección utiliza el conteo como método de ejemplo en este preámbulo, pero las opciones descritas se aplican a todas las subsecciones.</p><p>Todos los métodos de cálculo funcionan directamente en un modelo:</p><div class="code_container">
<pre><code class="language-ruby">Client.count
# SELECT COUNT(*) FROM clients
</code></pre>
</div>
<p>O en una relación:</p><div class="code_container">
<pre><code class="language-ruby">Client.where(first_name: 'Ryan').count
# SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')
</code></pre>
</div>
<p>También puede usar varios métodos de búsqueda en una relación para realizar cálculos complejos:</p><div class="code_container">
<pre><code class="language-ruby">Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
</code></pre>
</div>
<p>Que ejecutará:</p><div class="code_container">
<pre><code class="language-sql">SELECT COUNT(DISTINCT clients.id) FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = clients.id
  WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
</code></pre>
</div>
<h4 id="count"><a class="anchorlink" href="#count">22.1 Count</a></h4><p>Si desea ver cuántos registros hay en la tabla de su modelo, puede llamar a <code>Client.count</code> y eso devolverá el número. Si desea ser más específico y encontrar todos los clientes con su edad presente en la base de datos, puede usar <code>Client.count(:age)</code>.</p><p>Para ver las opciones, consulte la sección principal, <a href="#calculations">Calculations</a>.</p><h4 id="average"><a class="anchorlink" href="#average">22.2 Average</a></h4><p>Si desea ver el promedio de un cierto número en una de sus tablas, puede llamar al método <code>average</code> en la clase que se relaciona con la tabla. Esta llamada al método se verá así:</p><div class="code_container">
<pre><code class="language-ruby">Client.average("orders_count")
</code></pre>
</div>
<p>Esto devolverá un número (posiblemente un número de coma flotante como 3.14159265) que representa el valor promedio en el campo.</p><p>Para ver las opciones, consulte la sección principal, <a href="#calculations">Calculations</a>.</p><h4 id="minimum"><a class="anchorlink" href="#minimum">22.3 Minimum</a></h4><p>Si desea encontrar el valor mínimo de un campo en su tabla, puede llamar al método <code>minimum</code> en la clase que se relaciona con la tabla. Esta llamada al método se verá así:</p><div class="code_container">
<pre><code class="language-ruby">Client.minimum("age")
</code></pre>
</div>
<p>Para ver las opciones, consulte la sección principal, <a href="#calculations">Calculations</a>.</p><h4 id="maximum"><a class="anchorlink" href="#maximum">22.4 Maximum</a></h4><p>Si desea encontrar el valor máximo de un campo en su tabla, puede llamar al método <code>maximum</code> en la clase que se relaciona con la tabla. Esta llamada al método se verá así:</p><div class="code_container">
<pre><code class="language-ruby">Client.maximum("age")
</code></pre>
</div>
<p>Para ver las opciones, consulte la sección principal, <a href="#calculations">Calculations</a>.</p><h4 id="sum"><a class="anchorlink" href="#sum">22.5 Sum</a></h4><p>Si desea encontrar la suma de un campo para todos los registros en su tabla, puede llamar al método <code>sum</code> en la clase que se relaciona con la tabla. Esta llamada al método se verá así:</p><div class="code_container">
<pre><code class="language-ruby">Client.sum("orders_count")
</code></pre>
</div>
<p>Para ver las opciones, consulte la sección principal, <a href="#calculations">Calculations</a>.</p><h3 id="running-explain"><a class="anchorlink" href="#running-explain">23 Running EXPLAIN</a></h3><p>Puede ejecutar EXPLAIN en las consultas desencadenadas por las relaciones. Por ejemplo,</p><div class="code_container">
<pre><code class="language-ruby">User.where(id: 1).joins(:articles).explain
</code></pre>
</div>
<p>puede rendir</p><div class="code_container">
<pre><code class="language-sql">EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
</code></pre>
</div>
<p>bajo MySQL y MariaDB.</p><p>Active Record realiza una bonita impresión que emula la del
base de datos correspondiente. Entonces, la misma consulta que se ejecuta con el
el adaptador PostgreSQL produciría en su lugar</p><div class="code_container">
<pre><code class="language-sql">EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
</code></pre>
</div>
<p>La carga ansiosa puede desencadenar más de una consulta debajo del capó, y algunas consultas
puede necesitar los resultados de los anteriores. Por eso, <code>explain</code> en realidad
ejecuta la consulta y luego solicita los planes de consulta. Por ejemplo,</p><div class="code_container">
<pre><code class="language-ruby">User.where(id: 1).includes(:articles).explain
</code></pre>
</div>
<p>rendimientos</p><div class="code_container">
<pre><code class="language-sql">EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
</code></pre>
</div>
<p>bajo MySQL y MariaDB.</p><h4 id="interpreting-explain"><a class="anchorlink" href="#interpreting-explain">23.1 Interpreting EXPLAIN</a></h4><p>La interpretación del resultado de EXPLAIN está más allá del alcance de esta guía. los
siguientes consejos pueden ser útiles:</p>
<ul>
<li><p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="https://dev.mysql.com/doc/refman/en/explain-output.html">EXPLAIN Output Format</a></p></li>
<li><p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p></li>
<li><p>PostgreSQL: <a href="https://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>


        <h3>Comentarios Sobre el Contenido</h3>
        <p>
          Las guías de rieles se administran y publican en latinadeveloper/railsguides.es en GitHub.
        </p>
        <p>
          Si lee esta guía y encuentra algún texto o código incorrecto que le interese, no dude en enviar una solicitud de extracción en el repositorio anterior.

          Consulte el archivo README en GitHub para saber cómo enviar una solicitud de extracción.
          Please contribute if you see any typos or factual errors.
        </p>

      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a> License</p>
<p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>

    </div>
  </div>
</body>
</html>
