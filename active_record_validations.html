<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Validaciones de Active Record — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/default.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/prism/rails-guides.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/prism.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/responsive-tables.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="Validaciones de Active Record — Ruby on Rails Guides" />
  <meta name="description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Validaciones de Active RecordResumen de ValidacionesEsta guía le enseña cómo validar el estado de los objetos antes de que entren en la base de datos utilizando la característica de validación de Active Record.Después de leer esta guía, sabrá: Cómo usar los ayudantes(helpers) de validación de Active Record. Cómo crear tus propios métodos de validación. Cómo trabajar con los mensajes de error generados por el proceso de validación." />
  <meta property="og:description" content="NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN https://guides.rubyonrails.org.Validaciones de Active RecordResumen de ValidacionesEsta guía le enseña cómo validar el estado de los objetos antes de que entren en la base de datos utilizando la característica de validación de Active Record.Después de leer esta guía, sabrá: Cómo usar los ayudantes(helpers) de validación de Active Record. Cómo crear tus propios métodos de validación. Cómo trabajar con los mensajes de error generados por el proceso de validación." />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
<!--    <img src="images/edge_badge.png" alt="edge-badge" id="edge-badge" />-->
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">Más en <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        Más Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">Blog</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">Guías</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://stackoverflow.com/questions/tagged/ruby-on-rails">Pedir Ayuda</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Contribuir on GitHub</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Guías de Ruby on Rails">Guías de Ruby on Rails </a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">Inicio</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Index de Guías </a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>Empieza Aqui</dt>
                  <dd><a href="getting_started.html">Introducción a Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Modelos</dt>
                  <dd><a href="active_record_basics.html">Conceptos básicos de Active Record</a></dd>
                  <dd><a href="active_record_migrations.html">Migraciones de Active Record</a></dd>
                  <dd><a href="active_record_validations.html">Validaciones de Active Record</a></dd>
                  <dd><a href="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</a></dd>
                  <dd><a href="association_basics.html">Asociaciones de Active Record</a></dd>
                  <dd><a href="active_record_querying.html">Interfaz de Consulta de Active Record</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Vistas</dt>
                  <dd><a href="layouts_and_rendering.html">Diseños y Renderizado en Rails</a></dd>
                  <dd><a href="form_helpers.html">Ayudantes de Formulario de Action</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controladores</dt>
                  <dd><a href="action_controller_overview.html">Descripción General de Action Controller</a></dd>
                  <dd><a href="routing.html">Rails Routing Desde el Exterior Hacia Adentro</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Otros Componentes</dt>
                  <dd><a href="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</a></dd>
                  <dd><a href="action_mailer_basics.html">Conceptos Básicos de Action Mailer</a></dd>
                  <dd><a href="active_job_basics.html">Conceptos Básicos de Active Job</a></dd>
                  <dd><a href="active_storage_overview.html">Descripción General de Active Storage</a></dd>
                  <dd><a href="action_cable_overview.html">Descripción General de Action Cable</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Temas Avanzados</dt>
                  <dd><a href="i18n.html">Rails API de Internacionalización (I18n)</a></dd>
                  <dd><a href="testing.html">Prueba de Aplicaciones de Rails</a></dd>
                  <dd><a href="security.html">Seguridad de Aplicaciones Rails</a></dd>
                  <dd><a href="debugging_rails_applications.html">Depuración de Applications Rails</a></dd>
                  <dd><a href="configuring.html">Configuración de Aplicaciones de Rails</a></dd>
                  <dd><a href="command_line.html">La Línea de Comandos de Rails</a></dd>
                  <dd><a href="asset_pipeline.html">The Asset Pipeline (necesita traducción)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode) (necesita traducción)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode) (necesita traducción)</a></dd>
                  <dd><a href="caching_with_rails.html">Caching with Rails An Overview (necesita traducción)</a></dd>
                  <dd><a href="api_app.html">Using Rails for API-only Applications (necesita traducción)</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Extending Rails  (toda la sección necesita traducción)</dt>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                </div>
            </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">Contribuir</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guides Index</option>
              <optgroup label="Empieza Aqui">
                  <option value="getting_started.html">Introducción a Rails</option>
              </optgroup>
              <optgroup label="Modelos">
                  <option value="active_record_basics.html">Conceptos básicos de Active Record</option>
                  <option value="active_record_migrations.html">Migraciones de Active Record</option>
                  <option value="active_record_validations.html">Validaciones de Active Record</option>
                  <option value="active_record_callbacks.html">Devolución (callbacks) de Llamadas de Active Record</option>
                  <option value="association_basics.html">Asociaciones de Active Record</option>
                  <option value="active_record_querying.html">Interfaz de Consulta de Active Record</option>
              </optgroup>
              <optgroup label="Vistas">
                  <option value="layouts_and_rendering.html">Diseños y Renderizado en Rails</option>
                  <option value="form_helpers.html">Ayudantes de Formulario de Action</option>
              </optgroup>
              <optgroup label="Controladores">
                  <option value="action_controller_overview.html">Descripción General de Action Controller</option>
                  <option value="routing.html">Rails Routing Desde el Exterior Hacia Adentro</option>
              </optgroup>
              <optgroup label="Otros Componentes">
                  <option value="active_support_core_extensions.html">Extensiones de Núcleo de Active Support</option>
                  <option value="action_mailer_basics.html">Conceptos Básicos de Action Mailer</option>
                  <option value="active_job_basics.html">Conceptos Básicos de Active Job</option>
                  <option value="active_storage_overview.html">Descripción General de Active Storage</option>
                  <option value="action_cable_overview.html">Descripción General de Action Cable</option>
              </optgroup>
              <optgroup label="Temas Avanzados">
                  <option value="i18n.html">Rails API de Internacionalización (I18n)</option>
                  <option value="testing.html">Prueba de Aplicaciones de Rails</option>
                  <option value="security.html">Seguridad de Aplicaciones Rails</option>
                  <option value="debugging_rails_applications.html">Depuración de Applications Rails</option>
                  <option value="configuring.html">Configuración de Aplicaciones de Rails</option>
                  <option value="command_line.html">La Línea de Comandos de Rails</option>
                  <option value="asset_pipeline.html">The Asset Pipeline (necesita traducción)</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode) (necesita traducción)</option>
                  <option value="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode) (necesita traducción)</option>
                  <option value="caching_with_rails.html">Caching with Rails An Overview (necesita traducción)</option>
                  <option value="api_app.html">Using Rails for API-only Applications (necesita traducción)</option>
              </optgroup>
              <optgroup label="Extending Rails  (toda la sección necesita traducción)">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <p><strong>NO LEA ESTE ARCHIVO EN GITHUB, LAS GUÍAS SE PUBLICAN EN <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p><h2>Validaciones de Active Record</h2><p>Resumen de Validaciones</p><p>Esta guía le enseña cómo validar el estado de los objetos antes de que entren
en la base de datos utilizando la característica de validación de Active Record.</p><p>Después de leer esta guía, sabrá:</p>
<ul>
<li>Cómo usar los ayudantes(helpers) de validación de Active Record.</li>
<li>Cómo crear tus propios métodos de validación.</li>
<li>Cómo trabajar con los mensajes de error generados por el proceso de validación.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li>
<a href="#validations-overview">Validations Overview</a>

<ul>
<li><a href="#why-use-validations-questionmark">Why Use Validations?</a></li>
<li><a href="#when-does-validation-happen-questionmark">When Does Validation Happen?</a></li>
<li><a href="#skipping-validations">Skipping Validations</a></li>
<li><a href="#valid-questionmark-and-invalid-questionmark"><code>valid?</code> and <code>invalid?</code></a></li>
<li><a href="#validations-overview-errors"><code>errors[]</code></a></li>
</ul>
</li>
<li>
<a href="#validation-helpers">Validation Helpers</a>

<ul>
<li><a href="#acceptance"><code>acceptance</code></a></li>
<li><a href="#validates-associated"><code>validates_associated</code></a></li>
<li><a href="#confirmation"><code>confirmation</code></a></li>
<li><a href="#exclusion"><code>exclusion</code></a></li>
<li><a href="#format"><code>format</code></a></li>
<li><a href="#inclusion"><code>inclusion</code></a></li>
<li><a href="#length"><code>length</code></a></li>
<li><a href="#presence"><code>presence</code></a></li>
<li><a href="#absence"><code>absence</code></a></li>
<li><a href="#uniqueness"><code>uniqueness</code></a></li>
<li><a href="#validates-with"><code>validates_with</code></a></li>
</ul>
</li>
<li>
<a href="#common-validation-options">Common Validation Options</a>

<ul>
<li><a href="#allow-nil"><code>:allow_nil</code></a></li>
<li><a href="#allow-blank"><code>:allow_blank</code></a></li>
<li><a href="#message"><code>:message</code></a></li>
<li><a href="#on"><code>:on</code></a></li>
</ul>
</li>
<li><a href="#strict-validations">Strict Validations</a></li>
<li>
<a href="#conditional-validation">Conditional Validation</a>

<ul>
<li><a href="#using-a-symbol-with-if-and-unless">Using a Symbol with <code>:if</code> and <code>:unless</code></a></li>
<li><a href="#using-a-proc-with-if-and-unless">Using a Proc with <code>:if</code> and <code>:unless</code></a></li>
<li><a href="#grouping-conditional-validations">Grouping Conditional validations</a></li>
<li><a href="#combining-validation-conditions">Combining Validation Conditions</a></li>
</ul>
</li>
<li>
<a href="#performing-custom-validations">Performing Custom Validations</a>

<ul>
<li><a href="#custom-validators">Custom Validators</a></li>
<li><a href="#custom-methods">Custom Methods</a></li>
</ul>
</li>
<li>
<a href="#working-with-validation-errors">Working with Validation Errors</a>

<ul>
<li><a href="#working-with-validation-errors-errors"><code>errors</code></a></li>
<li><a href="#errors"><code>errors[]</code></a></li>
<li><a href="#errors-where-and-error-object"><code>errors.where</code> and error object</a></li>
<li><a href="#errors-add"><code>errors.add</code></a></li>
<li><a href="#errors-base">`errors[:base]</a></li>
<li><a href="#errors-clear"><code>errors.clear</code></a></li>
<li><a href="#errors-size"><code>errors.size</code></a></li>
</ul>
</li>
<li><a href="#displaying-validation-errors-in-views">Displaying Validation Errors in Views</a></li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="validations-overview"><a class="anchorlink" href="#validations-overview">1 Validations Overview</a></h3><p>Resumen de Validaciones</p><p>Aquí hay un ejemplo simple de una validación:</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # =&gt; true
Person.create(name: nil).valid? # =&gt; false
</code></pre>
</div>
<p>Como puedes ver, nuestra validación nos permite saber que nuestra <code>Person</code> no es válida
sin un atributo <code>name</code>. La segunda <code>Person</code> no será persistente sobre la
base de datos.</p><p>Antes de entrar en más detalles, hablemos sobre cómo las validaciones quedan en
panorama general de su aplicación.</p><h4 id="why-use-validations-questionmark"><a class="anchorlink" href="#why-use-validations-questionmark">1.1 Why Use Validations?</a></h4><p>¿Por qué Utilizamos Validaciones?</p><p>Las validaciones se utilizan para garantizar que solo se guarden datos válidos en su
base de datos. Por ejemplo, puede ser importante para su aplicación asegurarse de que
cada usuario proporciona una dirección de correo electrónico y una dirección postal. 
Las validaciones del nivel de modelo (Model-level) son la mejor manera de garantizar
que solo se guarden datos válidos en su base de datos. Son independientes de la base de datos,
no pueden ser ignorados por los usuarios finales y son conveniente para probar y mantener.
Rails incorpora ayuda en helpers para necesidades comúnes
, y también le permite crear sus propios métodos de validación .</p><p>Hay otras formas de validar los datos antes de guardarlos en su
base de datos, incluidas restricciones nativas de bases de datos, validaciones del lado del cliente y
validaciones a nivel de controlador. Aquí hay un resumen de los pros y los contras:</p>
<ul>
<li>Restricciones de la base de datos, y/o procedimientos almacenados que hacen el mecanismo de validación 
dependiente del motor de la base de datos y pueden hacer las pruebas y el mantenimiento más dificil. 
Sin embargo, si tu base de datos es utilizada por otras aplicaciones, puede ser una buena idea utilizar 
algunas restricciones en el nivel de base de datos. Adicionalmente, las validaciones en el nivel de base
de datos, pueden mantener la seguridad en algunas cosas (como la unicidad
en tablas muy utilizadas) que son difíciles de implementar de otra manera.</li>
<li>Las validaciones del lado del cliente suelen ser utilizadas, pero son generalmente poco confiables si se 
utilizan solas. Si son implementadas utilizando JavaScript, pueden ser sobrepasadas si el JavaScript 
está quitado en el navegador del usuario. Sin embargo, si se combinan con otras técnicas, las validaciones
del lado del cliente pueden ser una manera conveniente de proporcionar una respuesta inmediata a sus usuarios.</li>
<li>Las validaciones a nivel de controlador pueden ser tentadoras de usar, pero a menudo se vuelven
difícil de manejar y difícil de probar y mantener. Siempre que sea posible, es un buen
idea para mantener sus controladores delgados, ya que hará que su aplicación sea
placer de trabajar a largo plazo.</li>
</ul>
<p>Elija estos en ciertos casos específicos. Es la opinión del equipo de Rails.
que las validaciones a nivel de modelo son las más apropiadas en la mayoría de las circunstancias.</p><h4 id="when-does-validation-happen-questionmark"><a class="anchorlink" href="#when-does-validation-happen-questionmark">1.2 When Does Validation Happen?</a></h4><p>¿Cuándo sucede la validación?</p><p>Hay dos clases de objetos Active Record: aquellos que se corresponden a un registro en la base de datos y los que no.
Cuando crea un objeto nuevo, por ejemplo usando el método <code>new</code>, ese objeto todavía no pertenece a la base de datos.
Una vez que se llame <code>save</code> sobre ese objeto, se guardará en la tabla de base de datos adecuada.
Active Record utiliza el método de instancia new_record? para determinar si un objeto está ya en la base de datos o no.
Considera la siguiente clase Active Record:</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
end
</code></pre>
</div>
<p>Podemos ver cómo funciona mirando algunos resultados de  <code>bin/rails console</code>:</p><div class="code_container">
<pre><code class="language-ruby">$ bin/rails console
&gt;&gt; p = Person.new(name: "John Doe")
=&gt; #&lt;Person id: nil, name: "John Doe", created_at: nil, updated_at: nil&gt;
&gt;&gt; p.new_record?
=&gt; true
&gt;&gt; p.save
=&gt; true
&gt;&gt; p.new_record?
=&gt; false
</code></pre>
</div>
<p>Crear y guardar un nuevo registro enviará una operación SQL <code>INSERT</code> a la
base de datos. La actualización de un registro que existente enviará una operación SQL <code>UPDATE</code>.
Las validaciones generalmente se ejecutan antes de que estos comandos se envíen a
base de datos. Si una validación falla, el objeto se marcará como inválido y
Active Record no realizará la operación <code>INSERT</code> o <code>UPDATE</code>. Esto evita
almacenar un objeto que no es válido en la base de datos.
Puedes elegir que validaciones específicas sean ejecutadas cuando se
crea, guarda o actualiza un objeto.</p><p>PRECAUCIÓN: Hay muchas formas de cambiar el estado de un objeto en la base de datos.
Algunos métodos activarán validaciones, pero otros no. Esto significa que es
es posible guardar un objeto en la base de datos en un estado no válido si uno
no tiene cuidado.</p><p>Los siguientes métodos disparan validaciones, y guardarán un objeto en la 
base de datos solo si el objeto es válido:</p>
<ul>
<li><code>create</code></li>
<li><code>create!</code></li>
<li><code>save</code></li>
<li><code>save!</code></li>
<li><code>update</code></li>
<li><code>update!</code></li>
</ul>
<p>Las versiones de bang (p.e. <code>save!</code>) generan una excepción si el 
registro no es válido. Las versiones no-bang <code>save</code> y <code>update</code> devuelve 
<code>falso</code>, y <code>create</code> devuelve el objeto.</p><h4 id="skipping-validations"><a class="anchorlink" href="#skipping-validations">1.3 Skipping Validations</a></h4><p>Saltando las Validaciones</p><p>Los siguientes métodos omiten las validaciones y guardarán el objeto en la
base de datos sin darle importancia a su validez. Deben usarse con precaución.</p>
<ul>
<li><code>decrement!</code></li>
<li><code>decrement_counter</code></li>
<li><code>increment!</code></li>
<li><code>increment_counter</code></li>
<li><code>toggle!</code></li>
<li><code>touch</code></li>
<li><code>update_all</code></li>
<li><code>update_attribute</code></li>
<li><code>update_column</code></li>
<li><code>update_columns</code></li>
<li><code>update_counters</code></li>
</ul>
<p> Nota que <code>save</code> también tiene la capacidad de omitir validaciones si se pasa <code>validate:
false</code> como un argumento. Esta técnica debe usarse con precaución.</p>
<ul>
<li><code>save(validate: false)</code></li>
</ul>
<h4 id="valid-questionmark-and-invalid-questionmark"><a class="anchorlink" href="#valid-questionmark-and-invalid-questionmark">1.4 <code>valid?</code> and <code>invalid?</code></a></h4><p>Antes de guardar un objeto Active Record, Rails ejecuta sus validaciones.
Si estas validaciones producen algún error, Rails no guarda el objeto.</p><p>También puede ejecutar estas validaciones por su propia cuenta. <code>valid?</code> activa sus validaciones
y devuelve verdadero si no se encontraron errores en el objeto, y falso de lo contrario.
Como viste arriba:</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # =&gt; true
Person.create(name: nil).valid? # =&gt; false
</code></pre>
</div>
<p>Después de que Active Record haya realizado las validaciones, se puede acceder cualquier error
encontrado a través del método de instancia <code>errors</code>, que devuelve una colección de errores.
Por definición, un objeto es válido si esta colección está vacía después de ejecutarse
validaciones</p><p>Nota que un objeto instanciado con <code>new</code> no informará errores
incluso si es técnicamente inválido, porque las validaciones se ejecutan automáticamente
solo cuando se guarda el objeto, tal como con los métodos <code>create</code> o<code>save</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end

&gt;&gt; p = Person.new
# =&gt; #&lt;Person id: nil, name: nil&gt;
&gt;&gt; p.errors.size
# =&gt; 0

&gt;&gt; p.valid?
# =&gt; false
&gt;&gt; p.errors.objects.first.full_message
# =&gt; "Name can't be blank"

&gt;&gt; p = Person.create
# =&gt; #&lt;Person id: nil, name: nil&gt;
&gt;&gt; p.errors.objects.first.full_message
# =&gt; "Name can't be blank"

&gt;&gt; p.save
# =&gt; false

&gt;&gt; p.save!
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

&gt;&gt; Person.create!
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</code></pre>
</div>
<p><code>inválido?</code> es el inverso de <code>válido?</code>. Activa sus validaciones,
devuelve verdadero si se encontraron errores en el objeto, y falso de
lo contrario.</p><h4 id="validations-overview-errors"><a class="anchorlink" href="#validations-overview-errors">1.5 <code>errors[]</code></a></h4><p>Para verificar si un atributo particular de un objeto es válido o no, puede
use <code>errors[:attribute]</code>. Devuelve una matriz de todos los mensajes de error para
<code>:attribute</code>. Si no hay errores en el atributo especificado, se regresa una matriz vacía.</p><p>Este método solo es útil <em>después</em> de haberse ejecutado las validaciones, porque solo
inspecciona la recopilación de errores y no activa validaciones en sí mismo. Es
diferente del método <code>ActiveRecord::Base#invalid?</code>  que fue explicado anteriormente porque
no verifica la validez del objeto. Solo comprueba para ver
si hay errores que fueron encontrados en un atributo individual del objeto.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end

&gt;&gt; Person.new.errors[:name].any? # =&gt; false
&gt;&gt; Person.create.errors[:name].any? # =&gt; true
</code></pre>
</div>
<p>Cubriremos errores de validación en mayor profundidad en la sección <a href="#working-with-validation-errors">Working with Validation
Errors</a></p><h3 id="validation-helpers"><a class="anchorlink" href="#validation-helpers">2 Validation Helpers</a></h3><p>Helpers de Validación</p><p>Active Record ofrece muchos ayudantes de validación predefinidos que se pueden usar
directamente dentro de las definiciones de tus clases. Estos ayudantes proveen reglas
comúnes de validación. Cada vez que una validación falla, un error se agrega a la
colección de <code>errors</code> del objeto, y esto está asociado con el atributo que se esta validado.</p><p>Cada ayudante acepta un número arbitrario de nombres de atributos, entonces 
con una línea de código puedes añadir algún tipo de validadación a varios atributos.</p><p>Todos ellos aceptan las opciones <code>:on</code> y<code>:message</code>, que definen cuándo
se debe ejecutar la validación y qué mensaje se debe agregar a la colección de <code>errors</code>
si falla, respectivamente. La opción de <code>: on</code> toma uno de los valores
<code>:create</code> o<code>:update</code>. Hay un  mensaje de error por defecto
para cada uno de los ayudantes de validación. Estos mensajes se utilizan cuando
la opción <code>:mensaje</code> no está especificada. Echemos un vistazo a cada uno de los
Ayudantes disponibles. Vamos a ver a cada uno de los helpers disponibles.</p><h4 id="acceptance"><a class="anchorlink" href="#acceptance">2.1 <code>acceptance</code></a></h4><p>Este método valida que se haya marcado una casilla de verificación en la interfaz de 
usuario cuando se envie el formulario. Esto normalmente se usa cuando el usuario 
necesita aceptar términos de servicio de la aplicación, confirme que se lee algún texto
o un concepto similar.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: true
end
</code></pre>
</div>
<p>Esta verificación se realiza solo si <code>terms_of_service</code> no es <code>nil</code>.
El mensaje de error predeterminado para este helper es <em>"must be accepted"</em>.
También se puede pasar un mensaje personalizado a través de la opción `<code>message</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'must be abided' }
end
</code></pre>
</div>
<p>También se puede recibir una opción <code>:accept</code>, que determina los valores permitidos
que serán considerado como aceptado. Su valor predeterminado es <code>['1', true]</code> y puede ser
cambiado fácilmente.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: { accept: 'yes' }
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
</code></pre>
</div>
<p>Esta validación es específicamente para aplicaciones del web y este
<code>acceptance</code> no necesita registrarse en ningún lugar de su base de datos.
Si tu no tienes un campo para el, el ayudante creará un atributo virtual.
Si el campo si existe en su base de datos, la opción <code>accept</code> debe establecerse en
o incluir <code>true</code> o de lo contrario la validación no se ejecutará.</p><h4 id="validates-associated"><a class="anchorlink" href="#validates-associated">2.2 <code>validates_associated</code></a></h4><p>Debe usar este asistente cuando su modelo tenga asociaciones con otros modelos
y también se necesitan ser validados. Cuando intentas guardar tu objeto, <code>valid</code>
se llamará a cada uno de los objetos asociados.</p><div class="code_container">
<pre><code class="language-ruby">class Library &lt; ApplicationRecord
  has_many :books
  validates_associated :books
end
</code></pre>
</div>
<p>Esta validación funcionará con todos los tipos de asociación.</p><p>PRECAUCIÓN: No use <code>validates_associated</code> en ambos extremos de sus asociaciones.
Se llamarían entre sí en un bucle infinito.</p><p>El mensaje de error predeterminado para <code>validates_associated</code> es <em>"is invalid"</em>. Nota
que cada objeto asociado contendrá su propia colección de "<code>errors</code>; los errores 
no burbujean hasta el modelo que lo llama.</p><h4 id="confirmation"><a class="anchorlink" href="#confirmation">2.3 <code>confirmation</code></a></h4><p>Debería usar este asistente cuando tenga dos campos de texto que deberían recibir
exactamente el mismo contenido. Por ejemplo, es posible que desee confirmar una 
dirección de correo electrónico o una contraseña. Esta validación crea un atributo
virtual cuyo nombre es el nombre del campo que debe confirmarse adjuntando
con "_confirmación" .</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: true
end
</code></pre>
</div>
<p>En su plantilla de vista, podría usar algo como</p><div class="code_container">
<pre><code class="language-erb">&lt;%= text_field :person, :email %&gt;
&lt;%= text_field :person, :email_confirmation %&gt;
</code></pre>
</div>
<p>Esta verificación se realiza solo si <code>email_confirmation</code> no es <code>nil</code>. Para requerir
confirmación, asegúrese de agregar una verificación de presencia para el atributo de confirmación
(veremos <code>presence</code> más adelante en esta guía):</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
</code></pre>
</div>
<p>También hay una opción <code>:case_sensitive</code> que puede usar para definir si
la restricción de confirmación se distingue entre mayúsculas y minúsculas o no. Esta opción
por defecto es cierto.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
</code></pre>
</div>
<p>El mensaje de error predeterminado para este asistente es <em>"doesn't match confirmation"</em>.</p><h4 id="exclusion"><a class="anchorlink" href="#exclusion">2.4 <code>exclusion</code></a></h4><p>Este helper valida que los valores de los atributos no estén incluidos en un
conjunto determinado. De hecho, este conjunto puede ser cualquier objeto enumerable.</p><div class="code_container">
<pre><code class="language-ruby">class Account &lt; ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end
</code></pre>
</div>
<p>Este helper <code>exclusion</code> tiene una opción <code>:in</code> que recibe que recibe el conjunto de valores que
no serán aceptado para los atributos validados.  La opción :<code>in</code> tiene un alias llamado <code>:within</code>
que puedes utilizar para el mismo propósito, si lo quieres. Este ejemplo utiliza la opción
<code>:message</code> para demostrar como puedes incluir los valores de los atributos. Para ver las opciones 
completas del argumento del mensaje, consulte el <a href="#message">message documentation</a>.</p><p>El mensaje de error predeterminado es <em>"is reserved"</em>.</p><h4 id="format"><a class="anchorlink" href="#format">2.5 <code>format</code></a></h4><p>Este ayudante valida los valores de los atributos probando si coinciden con un
dada la expresión regular, que se especifica usando la opción <code>: with</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Product &lt; ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
</code></pre>
</div>
<p>Alternativamente, puedes requerir que el atributo específico no responda a la expresión regular utilizando la opción <code>:without</code>.</p><p>El mensaje de error por defecto es <em>"is invalid"</em>.</p><h4 id="inclusion"><a class="anchorlink" href="#inclusion">2.6 <code>inclusion</code></a></h4><p>Este ayudante valida que los valores de los atributos están incluidos en un conjunto dado.
De hecho, este conjunto puede ser cualquier objeto enumerable.</p><div class="code_container">
<pre><code class="language-ruby">class Coffee &lt; ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
</code></pre>
</div>
<p>Este helper <code>inclusion</code> tiene una opción <code>:in</code> que recibe que recibe el conjunto de valores que
serán aceptado. La opción :<code>in</code> tiene un alias llamado <code>:within</code> que puedes utilizar para 
el mismo propósito, si lo quieres. El ejemplo anterior usa la opción <code>:message</code> para mostrar 
cómo puede incluir el valor del atributo. Para ver las opciones completas del argumento 
del mensaje, consulte el <a href="#message">message documentation</a>.</p><p>El mensaje de error predeterminado es <em>"is not included in the list"</em>.</p><h4 id="length"><a class="anchorlink" href="#length">2.7 <code>length</code></a></h4><p>Este ayudante valida la longitud de los valores de los atributos. Proporciona una
variedad de opciones, por lo que puede especificar restricciones de longitud de diferentes maneras:</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
</code></pre>
</div>
<p>Las opciones de restricción de longitud son:</p>
<ul>
<li>
<code>:minimum</code> - El atributo no puede tener menos caracteres que una longitud específica.</li>
<li>
<code>:maximum</code> - El atributo no puede tener más caracteres que una longitud específica.</li>
<li>
<code>:in</code> (or <code>:within</code>) - La longitud del atributo debe estar contenida en un intervalo dado. 
El valor para esta opción de ser un rango.</li>
<li>
<code>:is</code> -  La longitud del atributo debe ser igual a un valor dado.</li>
</ul>
<p>Los mensajes de error por defecto dependen del tipo de validación de longitud que es utilizada. 
Puedes personalizar estos mensajes utilizando las opciones <code>:wrong_length</code>, <code>:too_long</code>, y
<code>:too_short</code> y <code>%{count}</code> como referencia para mostrar el número que corresponda para 
la restricción que se está utilizando. Todavía puedes usar la opción <code>:message</code> para especificar 
un mensaje de error.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
</code></pre>
</div>
<p>Nota que los mensajes de error predeterminados son plurales. Por predeterminado, coincidirá con 
un signo opcional seguido de una integral o número de punto flotante.</p><p> Para especificar que solo se permiten números integrales, establezca <code>:only_integer</code> 
 en verdadero. Entonces usará la     </p><div class="code_container">
<pre><code class="language-ruby">/\A[+-]?\d+\z/
</code></pre>
</div>
<p>expresión regular para validar el valor del atributo. De lo contrario, intentará
convertir el valor a un número usando <code>Float</code>. Los <code>Float</code> se convierten en<code>BigDecimal</code>
utilizando el valor de precisión de la columna o 15.</p><div class="code_container">
<pre><code class="language-ruby">class Player &lt; ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
</code></pre>
</div>
<p>El mensaje de error predeterminado es  <em>"must be an integer"</em>.</p><p>Además :only_integer, este helper también acepta las siguientes opciones para 
añadir restricciones a los valores acceptables:</p>
<ul>
<li>
<code>:greater_than</code> - Especifica que el valor del atributo debe debe ser mayor que
un valor determinado. El mensaje de error para esta opción es  <em>"must be greater than
%{count}"</em>.</li>
<li>
<code>:greater_than_or_equal_to</code> - Especifica que el valor del atributo debe ser mayor o 
igual a un valor determinado. El mensaje de error por defecto para esta opción es
<em>"must be greater than or equal to %{count}"</em>.</li>
<li>
<code>:equal_to</code> - Especifica que el valor del atributo debe ser igual a un valor 
determinado. El mensaje de error por defecto de esta opción es <em>"must be equal to %{count}"</em>.</li>
<li>
<code>:less_than</code> - Especifica que el valor del atributo debe ser menor que un determinado valor.
El mensaje de error de esta opción ess <em>"must be less than %{count}"</em>.</li>
<li>
<code>:less_than_or_equal_to</code> - Especifica que el valor del atributo debe ser menor o igual 
de un valor determinado. El mensaje de error por defecto es <em>"must be
less than or equal to %{count}"</em>.</li>
<li>
<code>:other_than</code> - Especifica que el valor debe ser distinto del valor proporcionado. El 
mensaje de error por defecto es <em>"must be other than %{count}"</em>.</li>
<li>
<code>:odd</code> -  Especifica que el valor debe ser un número impar si es configurado a true. El 
mensaje de error por defecto es <em>"must be odd"</em>.</li>
<li>
<code>:even</code> - especifica que el valor debe ser un número par si se establece a true. El 
mensaje de error por defecto es <em>"must be even"</em>.</li>
</ul>
<div class="note"><p>Por defecto, <code>numericality</code> no permite valores <code>nil</code>. Puedes utilizar la opción<code>allow_nil: true</code> para permitirlo.</p></div><p>El mensaje de error para esta opción es <em>"is not a number"</em>.</p><h4 id="presence"><a class="anchorlink" href="#presence">2.8 <code>presence</code></a></h4><p>Este ayudante valida que los atributos especificados no estén vacíos. Utiliza el método <code>blank?</code> para comprobar
si el valor es <code>nil</code> o una cadena esta en blancoese, es decir, una cadena que está vacía o que consta de 
espacios en blanco.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, :login, :email, presence: true
end
</code></pre>
</div>
<p>Si quieres estar seguro de que hay una asociación presente, tendras que probar
si el objeto asociado en sí está presente, y no la clave foránea utilizada para asignar la asociación.
De esta manera, no solo se verifica que la clave foránea no este vacía sino que también 
el objeto referenciado exista.</p><div class="code_container">
<pre><code class="language-ruby">class LineItem &lt; ApplicationRecord
  belongs_to :order
  validates :order, presence: true
end
</code></pre>
</div>
<p>Para validar qu los registros asociados cuya presencia se requiere, debe
especifique la opción <code>:inverse_of</code> para la asociación:</p><div class="code_container">
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  has_many :line_items, inverse_of: :order
end
</code></pre>
</div>
<p>Para validar los registros asociados cuya presencia se requiere, debe
especifica la opción <code>:inverse_of</code> para la asociación:</p><div class="code_container">
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  has_many :line_items, inverse_of: :order
end
</code></pre>
</div>
<p>Si validas la presencia de un objeto asociado a través de una relación <code>has_one</code>
o <code>has_many</code>, comprobará que el objeto no este en <code>blank?</code> ni <code>marked_for_destruction?</code>.</p><p>Como <code>false.blank?</code> es verdadero, si quieres validar la presencia de un booleano
debes usar una de las siguientes validaciones:</p><div class="code_container">
<pre><code class="language-ruby">validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
</code></pre>
</div>
<p>Al utilizar una de estas validaciones, se asegurará de que el valor NO sea <code>nil</code>
daría como resultado un valor <code>NULL</code> en la mayoría de los casos.</p><h4 id="absence"><a class="anchorlink" href="#absence">2.9 <code>absence</code></a></h4><p>Este ayudante valida que los atributos especificados están ausentes. Utiliza el
método <code>present?</code> para verificar si el valor no es <code>nil</code> o una cadena en blanco, que
es decir, una cadena que está vacía o que consta de espacios en blanco.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, :login, :email, absence: true
end
</code></pre>
</div>
<p>Si desea estar seguro de que una asociación está ausente, deberá probar si el objeto
asociado está ausente y no la clave foránea utilizada para mapear la asociación.</p><div class="code_container">
<pre><code class="language-ruby">class LineItem &lt; ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end
</code></pre>
</div>
<p>Para validar los registros asociados cuyo absence es necesario, debe especificar 
la opción <code>:inverse_of</code> para la asociación:</p><div class="code_container">
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  has_many :line_items, inverse_of: :order
end
</code></pre>
</div>
<p>Si valida la ausencia de un objeto asociado a través de una relación <code>has_one</code> o 
<code>has_many</code>, comprobará que el objeto no está <code>present?</code> ni <code>marked_for_destruction?</code>.</p><p>Como <code>false.present?</code> es falso, si quieres validar la presencia de un booleano
debes usar <code>validates :field_name, exclusion: { in: [true, false] }</code>.</p><p>El mensaje de error predeterminado es  <em>"must be blank"</em>.</p><h4 id="uniqueness"><a class="anchorlink" href="#uniqueness">2.10 <code>uniqueness</code></a></h4><p>Este asistente valida que el valor del atributo es único justo antes de
que el objeto se guarda. No crea una restricción de unicidad en la base de datos,
por lo tanto, puede suceder que dos conexiones de base de datos diferentes crean dos registros
con el mismo valor para una columna que pretende ser única. Para evitar eso,
debe crear un índice único en esa columna en su base de datos.</p><div class="code_container">
<pre><code class="language-ruby">class Account &lt; ApplicationRecord
  validates :email, uniqueness: true
end
</code></pre>
</div>
<p>La validación se realiza realizando una consulta SQL en la tabla del modelo,
buscando un registro existente con el mismo valor en ese atributo.</p><p>Hay una opción de <code>:scope</code> que puede utilizar para especificar otros atributos que se utilizan
para limitar la comprobación de unicidad:</p><div class="code_container">
<pre><code class="language-ruby">class Holiday &lt; ApplicationRecord
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end
</code></pre>
</div>
<p>Si desea crear una restricción de la base de datos para evitar posibles violaciones de una validación de unicidad utilizando la opción <code>:scope</code>, debe crear un índice único en ambas columnas de su base de datos. Consulte <a href="https://dev.mysql.com/doc/refman/en/multiple-column-indexes.html">the MySQL manual</a> para obtener más detalles sobre los índices de columnas múltiples  o <a href="https://www.postgresql.org/docs/current/static/ddl-constraints.html">the PostgreSQL manual</a> para ver ejemplos de restricciones únicas que se refieren a un grupo de columnas.</p><p>También hay una opción <code>:case_sensitive</code> que puede utilizar para definir si la restricción de unicidad
será sensible a mayúsculas o minúsculas. Esta opción predeterminada es true.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end
</code></pre>
</div>
<p>ADVERTENCIA. Tenga en cuenta que algunas bases de datos están configuradas para realizar búsquedas sin distinción 
con mayúsculas y minúsculas.</p><p>El mensaje de error predeterminado es  <em>"has already been taken"</em>.</p><h4 id="validates-with"><a class="anchorlink" href="#validates-with">2.11 <code>validates_with</code></a></h4><p>Este ayudante pasa el registro a una clase separada para validación.</p><div class="code_container">
<pre><code class="language-ruby">class GoodnessValidator &lt; ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors.add :base, "This person is evil"
    end
  end
end

class Person &lt; ApplicationRecord
  validates_with GoodnessValidator
end
</code></pre>
</div>
<p>Nota: Los errores agregados a <code>record.errors [:base]</code> se relacionan con el estado del registro
en conjunto, y no a un atributo específico.</p><p>El ayudante <code>validates_with</code> toma una clase, o una lista de clases para utilizar para esa validación.
No hay un mensaje de error predeterminado para <code>validates_with</code>. Debe agregar manualmente los errores
a la colección de errores del registro en la clase validator.</p><p>Para implementar el método validate, debe tener definido un parámetro <code>record,</code> que es el 
registro a validar.</p><p>Como todas las demás validaciones, <code>validates_with</code> toma las opciones <code>:if</code> ,<code>:unless</code> y <code>:on</code>. 
Si pasa otras opciones, se enviarán las opciones a la clase validator como <code>options</code>:</p><div class="code_container">
<pre><code class="language-ruby">class GoodnessValidator &lt; ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors.add :base, "This person is evil"
    end
  end
end

class Person &lt; ApplicationRecord
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
</code></pre>
</div>
<p>Nota que el validador se inicializará <em>sólo una vez</em> para todo el ciclo de vida de la aplicación, 
y no en cada ejecución de validación, así que tenga cuidado al usar variables de instancia dentro de ella.</p><p>Si su validador es lo suficientemente complejo como para que desee variables de instancia, puede utilizar 
fácilmente un objeto Ruby antiguo en su lugar:</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors.add :base, "This person is evil"
    end
  end

  # ...
end
</code></pre>
</div>
<p>Este helper valida los atributos contra un bloque. No tiene una función de validación
predefinida. Debes crear uno usando un bloque, y cada atributo es
pasado a <code>validates_each</code> y será probado contra él. En el siguiente ejemplo,
no queremos que los nombres y apellidos comiencen con minúsculas.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
</code></pre>
</div>
<p>El bloque recibe el registro, el nombre del atributo y el valor del atributo.
Puedes hacer lo que quieras para verificar los datos válidos dentro del bloque. Si tu
validación falla, debrias agregar un error al modelo, por lo tanto
haciéndolo inválido.</p><h3 id="common-validation-options"><a class="anchorlink" href="#common-validation-options">3 Common Validation Options</a></h3><p>Opciones de validación comunes</p><p>Estas son opciones de validación comunes:</p><h4 id="allow-nil"><a class="anchorlink" href="#allow-nil">3.1 <code>:allow_nil</code></a></h4><p>La <code>:allow_nil</code>  opción omite la validación cuando el valor que se valida es
<code>nil</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Coffee &lt; ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end
</code></pre>
</div>
<p>Para ver las opciones completas del argumento del mensaje, consulte el
<a href="#message">message documentation</a>.</p><h4 id="allow-blank"><a class="anchorlink" href="#allow-blank">3.2 <code>:allow_blank</code></a></h4><p>La <code>:allow_blank</code> opción es similar a la opción <code>:allow_nil</code>. Esta opción
dejará pasar la validación si el valor del atributo es <code>blank?</code>, como <code>nil</code> o por ejemplo
una cadena vacía. </p><div class="code_container">
<pre><code class="language-ruby">class Topic &lt; ApplicationRecord
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create(title: "").valid?  # =&gt; true
Topic.create(title: nil).valid? # =&gt; true
</code></pre>
</div>
<h4 id="message"><a class="anchorlink" href="#message">3.3 <code>:message</code></a></h4><p>Como ya has visto, la opción <code>:message</code> te permite especificar el mensaje que
se agregará a la colección de <code>errors</code> cuando falla la validación. Cuando esta
opción no se usa, Active Record usará el respectivo mensaje de error predeterminado 
para cada ayudante de validación. La opción <code>:message</code> acepta un <code>String</code> o <code>Proc</code>.</p><p>Un valor <code>String</code> <code>:message</code> opcionalmente puede contener cualquiera/todos del <code>%{value}</code>,
<code>%{attribute}</code>, y <code>%{model}</code> que serán reemplazados dinámicamente cuando
la validación falla. Este reemplazo se realiza utilizando la gem I18n, y los 
marcadores de posición deben coincidir exactamente, no se permiten espacios.</p><p>Un valor <code>Proc</code>: <code>mensaje</code> tiene dos argumentos: el objeto que se esta validando y
un hash con los pares clave-valor <code>:modelo</code>,<code>:atributo</code> y <code>:valor</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  # Hard-coded message
  validates :name, presence: { message: "must be given please" }

  # Message with dynamic attribute value. %{value} will be replaced with
  # the actual value of the attribute. %{attribute} and %{model} also
  # available.
  validates :age, numericality: { message: "%{value} seems wrong" }

  # Proc
  validates :username,
    uniqueness: {
      # object = person object being validated
      # data = { model: "Person", attribute: "Username", value: &lt;username&gt; }
      message: -&gt;(object, data) do
        "Hey #{object.name}!, #{data[:value]} is taken already! Try again #{Time.zone.tomorrow}"
      end
    }
end
</code></pre>
</div>
<h4 id="on"><a class="anchorlink" href="#on">3.4 <code>:on</code></a></h4><p>La opción <code>:on</code> le permite especificar cuándo se debe realizarse la validación. El 
comportamiento predeterminado para todos los ayudantes de validación integrados se 
debe ejecutar al guardar (save) (tanto cuando está creando un nuevo registro como 
cuando lo está actualizando). Si tu deseas cambiarlo, puedes usar <code>on: :create</code> para ejecutar
la validación solo cuando un nuevo registro es creado o <code>on: :update</code> para ejecutar 
la validación solo cuando un registro se está actualizado.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  # it will be possible to update email with a duplicated value
  validates :email, uniqueness: true, on: :create

  # it will be possible to create the record with a non-numerical age
  validates :age, numericality: true, on: :update

  # the default (validates on both create and update)
  validates :name, presence: true
end
</code></pre>
</div>
<p>También se puede usar <code>on:</code> para definir contextos personalizados. Los contextos 
personalizados deben ser se activados explícitamente pasando el nombre del contexto 
a <code>valid?</code>, <code>invalid?</code>, or <code>save</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
end

person = Person.new(age: 'thirty-three')
person.valid? # =&gt; true
person.valid?(:account_setup) # =&gt; false
person.errors.messages
 # =&gt; {:email=&gt;["has already been taken"], :age=&gt;["is not a number"]}
</code></pre>
</div>
<p><code>person.valid?(:account_setup)</code> ejecuta ambas validaciones sin guardar
el modelo. <code>person.save(context: :account_setup)</code> valida <code>person</code> en el contexto
<code>account_setup</code> antes de guardar.</p><p>Cuando se desencadena por un contexto explícito, las validaciones se ejecutan para ese contexto,
así como cualquier validación  <em>without</em> contexto.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
  validates :name, presence: true
end

person = Person.new
person.valid?(:account_setup) # =&gt; false
person.errors.messages
 # =&gt; {:email=&gt;["has already been taken"], :age=&gt;["is not a number"], :name=&gt;["can't be blank"]}
</code></pre>
</div>
<h3 id="strict-validations"><a class="anchorlink" href="#strict-validations">4 Strict Validations</a></h3><p>Validaciones estrictas</p><p>También se puede especificar validaciones para que sean estrictas y elevar
<code>ActiveModel::StrictValidationFailed</code> cuando el objeto no es válido.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: { strict: true }
end

Person.new.valid?  # =&gt; ActiveModel::StrictValidationFailed: Name can't be blank
</code></pre>
</div>
<p>También existe la posibilidad de pasar una excepción personalizada a la opción <code>:strict</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # =&gt; TokenGenerationException: Token can't be blank
</code></pre>
</div>
<h3 id="conditional-validation"><a class="anchorlink" href="#conditional-validation">5 Conditional Validation</a></h3><p>Validación Condicional</p><p>A veces tendrá sentido validar un objeto solo cuando un predicado dado
es satisfecho. Puedes hacerlo utilizando las opciones <code>:if</code> y <code>:unless</code>, que
pueden tomar un símbolo, un <code>Proc</code> o un<code>Array</code>. Puede usar la opción <code>:if</code>
cuando desee especificar cuándo la validación <strong>should</strong> debe ocurrir. Si tu
deseas especificar cuándo la validación <strong>should not</strong> no deberia ocurrir, 
entoncess puede usar la opción <code>:unless</code>.</p><h4 id="using-a-symbol-with-if-and-unless"><a class="anchorlink" href="#using-a-symbol-with-if-and-unless">5.1 Using a Symbol with <code>:if</code> and <code>:unless</code></a></h4><p>Puedes asociar las opciones <code>:if</code> y <code>:unless</code> con un símbolo correspondiente
al nombre del método que se llamará justo antes de que ocurra la validación.
Esta es la opción más utilizada.</p><div class="code_container">
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
</code></pre>
</div>
<h4 id="using-a-proc-with-if-and-unless"><a class="anchorlink" href="#using-a-proc-with-if-and-unless">5.2 Using a Proc with <code>:if</code> and <code>:unless</code></a></h4><p>Es posible asociar <code>:if</code> y<code>:unless</code> con un objeto <code>Proc</code> que sera llamado. 
El uso de un objeto <code>Proc</code> le da la capacidad de escribir una condición en 
línea en lugar de un método separado. Esta opción es la más adecuada para
una línea.</p><div class="code_container">
<pre><code class="language-ruby">class Account &lt; ApplicationRecord
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end
</code></pre>
</div>
<p>Como las <code>Lambdas</code> son un tipo de<code>Proc</code>, también se pueden usar para escribir en línea
condiciones de una manera más corta.</p><div class="code_container">
<pre><code class="language-ruby">validates :password, confirmation: true, unless: -&gt; { password.blank? }
</code></pre>
</div>
<h4 id="grouping-conditional-validations"><a class="anchorlink" href="#grouping-conditional-validations">5.3 Grouping Conditional validations</a></h4><p>Agrupación de validaciones condicionales</p><p>A veces es útil que varias validaciones usen una condición. Se puede lograr 
fácilmente usando <code>with_options</code>.</p><div class="code_container">
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end
</code></pre>
</div>
<p>Todas las validaciones dentro del bloque <code>with_options</code> tendrán automáticamente
pasó la condición <code>if::is_admin?</code></p><h4 id="combining-validation-conditions"><a class="anchorlink" href="#combining-validation-conditions">5.4 Combining Validation Conditions</a></h4><p>Combinando condiciones de validación</p><p>Por otro lado, cuando  condiciones múltiples definen si una validación debe o no
debe suceder, se puede usar un <code>Array</code>. Además, puedes aplicar los dos <code>:if</code> como
<code>:unless</code> a la misma validación</p><div class="code_container">
<pre><code class="language-ruby">class Computer &lt; ApplicationRecord
  validates :mouse, presence: true,
                    if: [Proc.new { |c| c.market.retail? }, :desktop?],
                    unless: Proc.new { |c| c.trackpad.present? }
end
</code></pre>
</div>
<p>La validación solo se ejecuta cuando todas las condiciones <code>:if</code> y ninguna de las
<code>:unless</code> las condiciones se evalúan para <code>true</code>.</p><h3 id="performing-custom-validations"><a class="anchorlink" href="#performing-custom-validations">6 Performing Custom Validations</a></h3><p>Realizar validaciones personalizadas</p><p>Cuando los ayudantes de validación integrados no son suficientes para sus necesidades, puedes\
escribir sus propios validadores o métodos de validación como prefiera.</p><h4 id="custom-validators"><a class="anchorlink" href="#custom-validators">6.1 Custom Validators</a></h4><p>Validadores personalizados</p><p>Los validadores personalizados son clases que heredan de <code>ActiveModel::Validator</code>. Estas 
clases deben implementar el método <code>validate</code> que toma un registro como argumento
y realiza la validación en él. El validador personalizado se llama utilizando el
método <code>validates_with</code>.</p><div class="code_container">
<pre><code class="language-ruby">class MyValidator &lt; ActiveModel::Validator
  def validate(record)
    unless record.name.start_with? 'X'
      record.errors.add :name, "Need a name starting with X please!"
    end
  end
end

class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
</code></pre>
</div>
<p>La forma más fácil de agregar validadores personalizados para validar atributos individuales
es con el conveniente <code>ActiveModel::EachValidator</code>. En este caso, la clase del validador 
personalizado debe implementar un método <code>validate_each</code> que requiere tres
argumentos: registro, atributo y valor. Estos corresponden a la instancia, del
atributo a validar, y el valor del atributo en el pasado.</p><div class="code_container">
<pre><code class="language-ruby">class EmailValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      record.errors.add attribute, (options[:message] || "is not an email")
    end
  end
end

class Person &lt; ApplicationRecord
  validates :email, presence: true, email: true
end
</code></pre>
</div>
<p>Como se muestra en el ejemplo, también puede combinar validaciones estándar con su
propios validadores personalizados.</p><h4 id="custom-methods"><a class="anchorlink" href="#custom-methods">6.2 Custom Methods</a></h4><p>Métodos personalizados</p><p>También se puede crear métodos que verifiquen el estado de sus modelos y agreguen
errores en la colección <code>errors</code> cuando no son válidos. Debes entonces
registrar estos métodos utilizando el <code>validate</code>
(<a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validate">API</a>)
método de clase, pasando los símbolos para los nombres de los métodos de validación.</p><p>Se puede pasar más de un símbolo para cada método de la clase y las las validaciones
respectivas se ejecutarán en el mismo orden en que se registraron.</p><p>El método <code>valid?</code> verificará que la colección de errores esté vacía,
por lo que sus métodos de validación personalizados deberían agregarle errores cuando
desear que la validación falle:</p><div class="code_container">
<pre><code class="language-ruby">class Invoice &lt; ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? &amp;&amp; expiration_date &lt; Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    if discount &gt; total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end
</code></pre>
</div>
<p>Por defecto, tales validaciones se ejecutarán cada vez que llame <code>valid?</code>
o se guarde el objeto. Pero también es posible controlar cuándo ejecutar estas
validaciones personalizadas dando una opción <code>:on</code> al método <code>validate</code>,
con: <code>:create</code> o <code>:update</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Invoice &lt; ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
</code></pre>
</div>
<h3 id="working-with-validation-errors"><a class="anchorlink" href="#working-with-validation-errors">7 Working with Validation Errors</a></h3><p>Trabajando con errores de validación</p><p>Los métodos <code>valid?</code> o <code>invalid?</code> Solo proporcionan un resumen del estado de validez. Sin embargo, puede profundizar en cada error individual utilizando varios métodos de la colección <code>errors</code>.</p><p>La siguiente es una lista de los métodos más utilizados. Consulte la documentación de <code>ActiveModel::Errors</code> para obtener una lista de todos los métodos disponibles.</p><h4 id="working-with-validation-errors-errors"><a class="anchorlink" href="#working-with-validation-errors-errors">7.1 <code>errors</code></a></h4><p>La puerta de enlace a través de la cual se puede profundizar en varios detalles de cada error.</p><p>Esto devuelve una instancia de la clase <code>ActiveModel::Errors</code> que contiene todos los errores,
cada error está representado por un objeto <code>ActiveModel::Error</code>.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # =&gt; false
person.errors.full_messages
 # =&gt; ["Name can't be blank", "Name is too short (minimum is 3 characters)"]

person = Person.new(name: "John Doe")
person.valid? # =&gt; true
person.errors.full_messages # =&gt; []
</code></pre>
</div>
<h4 id="errors"><a class="anchorlink" href="#errors">7.2 <code>errors[]</code></a></h4><p><code>errors[]</code> se usa cuando desea verificar los mensajes de error para un atributo específico. Devuelve una matriz de cadenas con todos los mensajes de error para el atributo dado, cada cadena con un mensaje de error. Si no hay errores relacionados con el atributo, devuelve una matriz vacía.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new(name: "John Doe")
person.valid? # =&gt; true
person.errors[:name] # =&gt; []

person = Person.new(name: "JD")
person.valid? # =&gt; false
person.errors[:name] # =&gt; ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # =&gt; false
person.errors[:name]
 # =&gt; ["can't be blank", "is too short (minimum is 3 characters)"]
</code></pre>
</div>
<h4 id="errors-where-and-error-object"><a class="anchorlink" href="#errors-where-and-error-object">7.3 <code>errors.where</code> and error object</a></h4><p>A veces podemos necesitar más información sobre cada error junto a su mensaje. Cada error se encapsula como un objeto <code>ActiveModel::Error</code>, y el método <code>where</code> es la forma más común de acceso.</p><p><code>where</code> devuelve una matriz de objetos de error, filtrados por varios grados de condiciones.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # =&gt; false

&gt;&gt; person.errors.where(:name) # errors linked to :name attribute
&gt;&gt; person.errors.where(:name, :too_short) # further filtered to only :too_short type error
</code></pre>
</div>
<p>Puede leer información diversa de estos objetos de error:</p><div class="code_container">
<pre><code class="language-ruby">&gt;&gt; error = person.errors.where(:name).last
&gt;&gt; error.attribute # =&gt; :name
&gt;&gt; error.type # =&gt; :too_short
&gt;&gt; error.options[:count] # =&gt; 3
</code></pre>
</div>
<p>También se puede generar el mensaje de error:</p>
<blockquote>
<blockquote>
<p>error.message # =&gt; "is too short (minimum is 3 characters)"
error.full_message # =&gt; "Name is too short (minimum is 3 characters)"</p>
</blockquote>
</blockquote>
<p>El método <code>full_message</code> genera un mensaje más fácil de usar, con el nombre del atributo en mayúscula antepuesto.</p><h4 id="errors-add"><a class="anchorlink" href="#errors-add">7.4 <code>errors.add</code></a></h4><p>El método <code>add</code> crea el objeto de error tomando el <code>attribute</code>, el error <code>type</code> y opciones adicionales en un hash. Esto es útil para escribir su propio validador.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validate do |person|
    errors.add :name, :too_plain, message: "is not cool enough"
  end
end

person = Person.create
person.errors.where(:name).first.type # =&gt; :too_plain
person.errors.where(:name).first.full_message # =&gt; "Name is not cool enough"
</code></pre>
</div>
<h4 id="errors-base"><a class="anchorlink" href="#errors-base">7.5 `errors[:base]</a></h4><p>Puedes agregar errores relacionados con el estado del objeto como un todo, en lugar de estar relacionados con un atributo específico. Puede agregar errores a <code>:base</code> cuando desee decir que el objeto no es válido, sin importar los valores de sus atributos.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validate do |person|
    errors.add :base, :invalid, message: "This person is invalid because ..."
  end
end

person = Person.create
person.errors.where(:base).first.full_message # =&gt; "This person is invalid because ..."
</code></pre>
</div>
<h4 id="errors-clear"><a class="anchorlink" href="#errors-clear">7.6 <code>errors.clear</code></a></h4><p>El método <code>clear</code> se usa cuando intencionalmente desea borrar la colección <code>errors</code>. Por supuesto, llamar a <code>errors.clear</code> sobre un objeto no válido no lo hará realmente válido: la colección <code>errors</code> ahora estará vacía, pero la próxima vez que llame a <code>valid?</code> o cualquier método que intente guardar este objeto a la base de datos, las validaciones se ejecutarán nuevamente. Si alguna de las validaciones falla, la colección de <code>errores</code> se completará nuevamente.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # =&gt; false
person.errors.empty? # =&gt; false

person.errors.clear
person.errors.empty? # =&gt; true

person.save # =&gt; false

person.errors.empty? # =&gt; false
</code></pre>
</div>
<h4 id="errors-size"><a class="anchorlink" href="#errors-size">7.7 <code>errors.size</code></a></h4><p>El método <code>size</code> devuelve el número total de errores para el objeto.</p><div class="code_container">
<pre><code class="language-ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # =&gt; false
person.errors.size # =&gt; 2

person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # =&gt; true
person.errors.size # =&gt; 0
</code></pre>
</div>
<h3 id="displaying-validation-errors-in-views"><a class="anchorlink" href="#displaying-validation-errors-in-views">8 Displaying Validation Errors in Views</a></h3><p>Mostrar errores de validación en vistas</p><p>Una vez que haya creado un modelo y agregado las validaciones, si ese modelo se crea a través de
un formulario en la web, es probable que desee mostrar un mensaje de error cuando uno de los
las validaciones fallan.</p><p>Debido a que cada aplicación maneja este tipo de cosas de manera diferente, Rails no incluye
ningún asistente de vista para ayudarlo a generar estos mensajes directamente.
Sin embargo, debido a la gran cantidad de métodos que Rails le brinda para interactuar con
validaciones en general, puede construir el suyo propio. Además, cuando
generando un dcaffold, Rails pondrá algo de ERB en el <code>_form.html.erb</code> que
genera que muestra la lista completa de errores en ese modelo.</p><p>Suponiendo que tenemos un modelo que se ha guardado en un variable de instancia llamado
<code>@artículo</code>, se ve así:</p><div class="code_container">
<pre><code class="language-ruby">&lt;% if @article.errors.any? %&gt;
  &lt;div id="error_explanation"&gt;
    &lt;h2&gt;&lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited this article from being saved:&lt;/h2&gt;

    &lt;ul&gt;
    &lt;% @article.errors.each do |error| %&gt;
      &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
</div>
<p>Además, si usa los ayudantes de formulario de Rails para generar sus formularios, cuando
se produce un error de validación en un campo, generará un <code>&lt;div&gt;</code> adicional alrededor de
la entrada.</p><div class="code_container">
<pre><code class="language-xml">&lt;div class="field_with_errors"&gt;
 &lt;input id="article_title" name="article[title]" size="30" type="text" value=""&gt;
&lt;/div&gt;
</code></pre>
</div>
<p>Luego puedes diseñar este div como quieras. El scaffold predeterminado que
Rails genera, por ejemplo, agrega esta regla CSS:</p><div class="code_container">
<pre><code class="language-plain">.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}
</code></pre>
</div>
<p>Esto significa que cualquier campo con un error termina con un borde rojo de 2 píxeles.</p>

        <h3>Comentarios Sobre el Contenido</h3>
        <p>
          Las guías de rieles se administran y publican en latinadeveloper/railsguides.es en GitHub.
        </p>
        <p>
          Si lee esta guía y encuentra algún texto o código incorrecto que le interese, no dude en enviar una solicitud de extracción en el repositorio anterior.

          Consulte el archivo README en GitHub para saber cómo enviar una solicitud de extracción.
          Please contribute if you see any typos or factual errors.
        </p>

      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a> License</p>
<p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>

    </div>
  </div>
</body>
</html>
